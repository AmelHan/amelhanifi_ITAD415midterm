<html>
<head>
<title>functoolz.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
functoolz.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span><span class="s0">, </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">attrgetter</span><span class="s0">, </span><span class="s1">not_</span>
<span class="s0">from </span><span class="s1">importlib </span><span class="s0">import </span><span class="s1">import_module</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">MethodType</span>

<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">no_default</span>

<span class="s1">PYPY = hasattr(sys</span><span class="s0">, </span><span class="s2">'pypy_version_info'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.version_info[</span><span class="s3">0</span><span class="s1">] &gt; </span><span class="s3">2</span>


<span class="s1">__all__ = (</span><span class="s2">'identity'</span><span class="s0">, </span><span class="s2">'apply'</span><span class="s0">, </span><span class="s2">'thread_first'</span><span class="s0">, </span><span class="s2">'thread_last'</span><span class="s0">, </span><span class="s2">'memoize'</span><span class="s0">,</span>
           <span class="s2">'compose'</span><span class="s0">, </span><span class="s2">'compose_left'</span><span class="s0">, </span><span class="s2">'pipe'</span><span class="s0">, </span><span class="s2">'complement'</span><span class="s0">, </span><span class="s2">'juxt'</span><span class="s0">, </span><span class="s2">'do'</span><span class="s0">,</span>
           <span class="s2">'curry'</span><span class="s0">, </span><span class="s2">'flip'</span><span class="s0">, </span><span class="s2">'excepts'</span><span class="s1">)</span>

<span class="s1">PYPY = hasattr(sys</span><span class="s0">, </span><span class="s2">'pypy_version_info'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">identity(x):</span>
    <span class="s4">&quot;&quot;&quot; Identity function. Return x 
 
    &gt;&gt;&gt; identity(3) 
    3 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">apply(*func_and_args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; Applies a function and returns the results 
 
    &gt;&gt;&gt; def double(x): return 2*x 
    &gt;&gt;&gt; def inc(x):    return x + 1 
    &gt;&gt;&gt; apply(double, 5) 
    10 
 
    &gt;&gt;&gt; tuple(map(apply, [double, inc, double], [10, 500, 8000])) 
    (20, 501, 16000) 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">func_and_args:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'func argument is required'</span><span class="s1">)</span>
    <span class="s1">func</span><span class="s0">, </span><span class="s1">args = func_and_args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">func_and_args[</span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s0">return </span><span class="s1">func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">thread_first(val</span><span class="s0">, </span><span class="s1">*forms):</span>
    <span class="s4">&quot;&quot;&quot; Thread value through a sequence of functions/forms 
 
    &gt;&gt;&gt; def double(x): return 2*x 
    &gt;&gt;&gt; def inc(x):    return x + 1 
    &gt;&gt;&gt; thread_first(1, inc, double) 
    4 
 
    If the function expects more than one input you can specify those inputs 
    in a tuple.  The value is used as the first input. 
 
    &gt;&gt;&gt; def add(x, y): return x + y 
    &gt;&gt;&gt; def pow(x, y): return x**y 
    &gt;&gt;&gt; thread_first(1, (add, 4), (pow, 2))  # pow(add(1, 4), 2) 
    25 
 
    So in general 
        thread_first(x, f, (g, y, z)) 
    expands to 
        g(f(x), y, z) 
 
    See Also: 
        thread_last 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">evalform_front(val</span><span class="s0">, </span><span class="s1">form):</span>
        <span class="s0">if </span><span class="s1">callable(form):</span>
            <span class="s0">return </span><span class="s1">form(val)</span>
        <span class="s0">if </span><span class="s1">isinstance(form</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">func</span><span class="s0">, </span><span class="s1">args = form[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">form[</span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s1">args = (val</span><span class="s0">,</span><span class="s1">) + args</span>
            <span class="s0">return </span><span class="s1">func(*args)</span>
    <span class="s0">return </span><span class="s1">reduce(evalform_front</span><span class="s0">, </span><span class="s1">forms</span><span class="s0">, </span><span class="s1">val)</span>


<span class="s0">def </span><span class="s1">thread_last(val</span><span class="s0">, </span><span class="s1">*forms):</span>
    <span class="s4">&quot;&quot;&quot; Thread value through a sequence of functions/forms 
 
    &gt;&gt;&gt; def double(x): return 2*x 
    &gt;&gt;&gt; def inc(x):    return x + 1 
    &gt;&gt;&gt; thread_last(1, inc, double) 
    4 
 
    If the function expects more than one input you can specify those inputs 
    in a tuple.  The value is used as the last input. 
 
    &gt;&gt;&gt; def add(x, y): return x + y 
    &gt;&gt;&gt; def pow(x, y): return x**y 
    &gt;&gt;&gt; thread_last(1, (add, 4), (pow, 2))  # pow(2, add(4, 1)) 
    32 
 
    So in general 
        thread_last(x, f, (g, y, z)) 
    expands to 
        g(y, z, f(x)) 
 
    &gt;&gt;&gt; def iseven(x): 
    ...     return x % 2 == 0 
    &gt;&gt;&gt; list(thread_last([1, 2, 3], (map, inc), (filter, iseven))) 
    [2, 4] 
 
    See Also: 
        thread_first 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">evalform_back(val</span><span class="s0">, </span><span class="s1">form):</span>
        <span class="s0">if </span><span class="s1">callable(form):</span>
            <span class="s0">return </span><span class="s1">form(val)</span>
        <span class="s0">if </span><span class="s1">isinstance(form</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">func</span><span class="s0">, </span><span class="s1">args = form[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">form[</span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s1">args = args + (val</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">func(*args)</span>
    <span class="s0">return </span><span class="s1">reduce(evalform_back</span><span class="s0">, </span><span class="s1">forms</span><span class="s0">, </span><span class="s1">val)</span>


<span class="s0">def </span><span class="s1">instanceproperty(fget=</span><span class="s0">None, </span><span class="s1">fset=</span><span class="s0">None, </span><span class="s1">fdel=</span><span class="s0">None, </span><span class="s1">doc=</span><span class="s0">None, </span><span class="s1">classval=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; Like @property, but returns ``classval`` when used as a class attribute 
 
    &gt;&gt;&gt; class MyClass(object): 
    ...     '''The class docstring''' 
    ...     @instanceproperty(classval=__doc__) 
    ...     def __doc__(self): 
    ...         return 'An object docstring' 
    ...     @instanceproperty 
    ...     def val(self): 
    ...         return 42 
    ... 
    &gt;&gt;&gt; MyClass.__doc__ 
    'The class docstring' 
    &gt;&gt;&gt; MyClass.val is None 
    True 
    &gt;&gt;&gt; obj = MyClass() 
    &gt;&gt;&gt; obj.__doc__ 
    'An object docstring' 
    &gt;&gt;&gt; obj.val 
    42 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">fget </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">partial(instanceproperty</span><span class="s0">, </span><span class="s1">fset=fset</span><span class="s0">, </span><span class="s1">fdel=fdel</span><span class="s0">, </span><span class="s1">doc=doc</span><span class="s0">,</span>
                       <span class="s1">classval=classval)</span>
    <span class="s0">return </span><span class="s1">InstanceProperty(fget=fget</span><span class="s0">, </span><span class="s1">fset=fset</span><span class="s0">, </span><span class="s1">fdel=fdel</span><span class="s0">, </span><span class="s1">doc=doc</span><span class="s0">,</span>
                            <span class="s1">classval=classval)</span>


<span class="s0">class </span><span class="s1">InstanceProperty(property):</span>
    <span class="s4">&quot;&quot;&quot; Like @property, but returns ``classval`` when used as a class attribute 
 
    Should not be used directly.  Use ``instanceproperty`` instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">fget=</span><span class="s0">None, </span><span class="s1">fset=</span><span class="s0">None, </span><span class="s1">fdel=</span><span class="s0">None, </span><span class="s1">doc=</span><span class="s0">None,</span>
                 <span class="s1">classval=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.classval = classval</span>
        <span class="s1">property.__init__(self</span><span class="s0">, </span><span class="s1">fget=fget</span><span class="s0">, </span><span class="s1">fset=fset</span><span class="s0">, </span><span class="s1">fdel=fdel</span><span class="s0">, </span><span class="s1">doc=doc)</span>

    <span class="s0">def </span><span class="s1">__get__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.classval</span>
        <span class="s0">return </span><span class="s1">property.__get__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">type)</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">state = (self.fget</span><span class="s0">, </span><span class="s1">self.fset</span><span class="s0">, </span><span class="s1">self.fdel</span><span class="s0">, </span><span class="s1">self.__doc__</span><span class="s0">, </span><span class="s1">self.classval)</span>
        <span class="s0">return </span><span class="s1">InstanceProperty</span><span class="s0">, </span><span class="s1">state</span>


<span class="s0">class </span><span class="s1">curry(object):</span>
    <span class="s4">&quot;&quot;&quot; Curry a callable function 
 
    Enables partial application of arguments through calling a function with an 
    incomplete set of arguments. 
 
    &gt;&gt;&gt; def mul(x, y): 
    ...     return x * y 
    &gt;&gt;&gt; mul = curry(mul) 
 
    &gt;&gt;&gt; double = mul(2) 
    &gt;&gt;&gt; double(10) 
    20 
 
    Also supports keyword arguments 
 
    &gt;&gt;&gt; @curry                  # Can use curry as a decorator 
    ... def f(x, y, a=10): 
    ...     return a * (x + y) 
 
    &gt;&gt;&gt; add = f(a=1) 
    &gt;&gt;&gt; add(2, 3) 
    5 
 
    See Also: 
        toolz.curried - namespace of curried functions 
                        https://toolz.readthedocs.io/en/latest/curry.html 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'__init__() takes at least 2 arguments (1 given)'</span><span class="s1">)</span>
        <span class="s1">func</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s0">if not </span><span class="s1">callable(func):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Input must be callable&quot;</span><span class="s1">)</span>

        <span class="s5"># curry- or functools.partial-like object?  Unpack and merge arguments</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">'func'</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">'args'</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">'keywords'</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">isinstance(func.args</span><span class="s0">, </span><span class="s1">tuple)</span>
        <span class="s1">):</span>
            <span class="s1">_kwargs = {}</span>
            <span class="s0">if </span><span class="s1">func.keywords:</span>
                <span class="s1">_kwargs.update(func.keywords)</span>
            <span class="s1">_kwargs.update(kwargs)</span>
            <span class="s1">kwargs = _kwargs</span>
            <span class="s1">args = func.args + args</span>
            <span class="s1">func = func.func</span>

        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s1">self._partial = partial(func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._partial = partial(func</span><span class="s0">, </span><span class="s1">*args)</span>

        <span class="s1">self.__doc__ = getattr(func</span><span class="s0">, </span><span class="s2">'__doc__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.__name__ = getattr(func</span><span class="s0">, </span><span class="s2">'__name__'</span><span class="s0">, </span><span class="s2">'&lt;curry&gt;'</span><span class="s1">)</span>
        <span class="s1">self.__module__ = getattr(func</span><span class="s0">, </span><span class="s2">'__module__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.__qualname__ = getattr(func</span><span class="s0">, </span><span class="s2">'__qualname__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self._sigspec = </span><span class="s0">None</span>
        <span class="s1">self._has_unknown_args = </span><span class="s0">None</span>

    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">func(self):</span>
        <span class="s0">return </span><span class="s1">self._partial.func</span>

    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">__signature__(self):</span>
        <span class="s1">sig = inspect.signature(self.func)</span>
        <span class="s1">args = self.args </span><span class="s0">or </span><span class="s1">()</span>
        <span class="s1">keywords = self.keywords </span><span class="s0">or </span><span class="s1">{}</span>
        <span class="s0">if </span><span class="s1">is_partial_args(self.func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">keywords</span><span class="s0">, </span><span class="s1">sig) </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'curry object has incorrect arguments'</span><span class="s1">)</span>

        <span class="s1">params = list(sig.parameters.values())</span>
        <span class="s1">skip = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">params[:len(args)]:</span>
            <span class="s0">if </span><span class="s1">param.kind == param.VAR_POSITIONAL:</span>
                <span class="s0">break</span>
            <span class="s1">skip += </span><span class="s3">1</span>

        <span class="s1">kwonly = </span><span class="s0">False</span>
        <span class="s1">newparams = []</span>
        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">params[skip:]:</span>
            <span class="s1">kind = param.kind</span>
            <span class="s1">default = param.default</span>
            <span class="s0">if </span><span class="s1">kind == param.VAR_KEYWORD:</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">kind == param.VAR_POSITIONAL:</span>
                <span class="s0">if </span><span class="s1">kwonly:</span>
                    <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">param.name </span><span class="s0">in </span><span class="s1">keywords:</span>
                <span class="s1">default = keywords[param.name]</span>
                <span class="s1">kind = param.KEYWORD_ONLY</span>
                <span class="s1">kwonly = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">kwonly:</span>
                    <span class="s1">kind = param.KEYWORD_ONLY</span>
                <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">param.empty:</span>
                    <span class="s1">default = no_default</span>
            <span class="s1">newparams.append(param.replace(default=default</span><span class="s0">, </span><span class="s1">kind=kind))</span>

        <span class="s0">return </span><span class="s1">sig.replace(parameters=newparams)</span>

    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">args(self):</span>
        <span class="s0">return </span><span class="s1">self._partial.args</span>

    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">keywords(self):</span>
        <span class="s0">return </span><span class="s1">self._partial.keywords</span>

    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">func_name(self):</span>
        <span class="s0">return </span><span class="s1">self.__name__</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">str(self.func)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">repr(self.func)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">return </span><span class="s1">hash((self.func</span><span class="s0">, </span><span class="s1">self.args</span><span class="s0">,</span>
                     <span class="s1">frozenset(self.keywords.items()) </span><span class="s0">if </span><span class="s1">self.keywords</span>
                     <span class="s0">else None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">(isinstance(other</span><span class="s0">, </span><span class="s1">curry) </span><span class="s0">and </span><span class="s1">self.func == other.func </span><span class="s0">and</span>
                <span class="s1">self.args == other.args </span><span class="s0">and </span><span class="s1">self.keywords == other.keywords)</span>

    <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._partial(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">if </span><span class="s1">self._should_curry(args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">exc):</span>
                <span class="s0">return </span><span class="s1">self.bind(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">raise</span>

    <span class="s0">def </span><span class="s1">_should_curry(self</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">exc=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">func = self.func</span>
        <span class="s1">args = self.args + args</span>
        <span class="s0">if </span><span class="s1">self.keywords:</span>
            <span class="s1">kwargs = dict(self.keywords</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">self._sigspec </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sigspec = self._sigspec = _sigs.signature_or_spec(func)</span>
            <span class="s1">self._has_unknown_args = has_varargs(func</span><span class="s0">, </span><span class="s1">sigspec) </span><span class="s0">is not False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sigspec = self._sigspec</span>

        <span class="s0">if </span><span class="s1">is_partial_args(func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">sigspec) </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s5"># Nothing can make the call valid</span>
            <span class="s0">return False</span>
        <span class="s0">elif </span><span class="s1">self._has_unknown_args:</span>
            <span class="s5"># The call may be valid and raised a TypeError, but we curry</span>
            <span class="s5"># anyway because the function may have `*args`.  This is useful</span>
            <span class="s5"># for decorators with signature `func(*args, **kwargs)`.</span>
            <span class="s0">return True</span>
        <span class="s0">elif not </span><span class="s1">is_valid_args(func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">sigspec):</span>
            <span class="s5"># Adding more arguments may make the call valid</span>
            <span class="s0">return True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># There was a genuine TypeError</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">bind(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">type(self)(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">call(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">self._partial(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">__get__(self</span><span class="s0">, </span><span class="s1">instance</span><span class="s0">, </span><span class="s1">owner):</span>
        <span class="s0">if </span><span class="s1">instance </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">curry(self</span><span class="s0">, </span><span class="s1">instance)</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">func = self.func</span>
        <span class="s1">modname = getattr(func</span><span class="s0">, </span><span class="s2">'__module__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">qualname = getattr(func</span><span class="s0">, </span><span class="s2">'__qualname__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">qualname </span><span class="s0">is None</span><span class="s1">:  </span><span class="s5"># pragma: no cover</span>
            <span class="s1">qualname = getattr(func</span><span class="s0">, </span><span class="s2">'__name__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">is_decorated = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">modname </span><span class="s0">and </span><span class="s1">qualname:</span>
            <span class="s1">attrs = []</span>
            <span class="s1">obj = import_module(modname)</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">qualname.split(</span><span class="s2">'.'</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">curry):</span>
                    <span class="s1">attrs.append(</span><span class="s2">'func'</span><span class="s1">)</span>
                    <span class="s1">obj = obj.func</span>
                <span class="s1">obj = getattr(obj</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">break</span>
                <span class="s1">attrs.append(attr)</span>
            <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">curry) </span><span class="s0">and </span><span class="s1">obj.func </span><span class="s0">is </span><span class="s1">func:</span>
                <span class="s1">is_decorated = obj </span><span class="s0">is </span><span class="s1">self</span>
                <span class="s1">qualname = </span><span class="s2">'.'</span><span class="s1">.join(attrs)</span>
                <span class="s1">func = </span><span class="s2">'%s:%s' </span><span class="s1">% (modname</span><span class="s0">, </span><span class="s1">qualname)</span>

        <span class="s5"># functools.partial objects can't be pickled</span>
        <span class="s1">userdict = tuple((k</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self.__dict__.items()</span>
                         <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">'_partial'</span><span class="s0">, </span><span class="s2">'_sigspec'</span><span class="s1">))</span>
        <span class="s1">state = (type(self)</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">self.args</span><span class="s0">, </span><span class="s1">self.keywords</span><span class="s0">, </span><span class="s1">userdict</span><span class="s0">,</span>
                 <span class="s1">is_decorated)</span>
        <span class="s0">return </span><span class="s1">_restore_curry</span><span class="s0">, </span><span class="s1">state</span>


<span class="s0">def </span><span class="s1">_restore_curry(cls</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">userdict</span><span class="s0">, </span><span class="s1">is_decorated):</span>
    <span class="s0">if </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">modname</span><span class="s0">, </span><span class="s1">qualname = func.rsplit(</span><span class="s2">':'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">obj = import_module(modname)</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">qualname.split(</span><span class="s2">'.'</span><span class="s1">):</span>
            <span class="s1">obj = getattr(obj</span><span class="s0">, </span><span class="s1">attr)</span>
        <span class="s0">if </span><span class="s1">is_decorated:</span>
            <span class="s0">return </span><span class="s1">obj</span>
        <span class="s1">func = obj.func</span>
    <span class="s1">obj = cls(func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**(kwargs </span><span class="s0">or </span><span class="s1">{}))</span>
    <span class="s1">obj.__dict__.update(userdict)</span>
    <span class="s0">return </span><span class="s1">obj</span>


<span class="s1">@curry</span>
<span class="s0">def </span><span class="s1">memoize(func</span><span class="s0">, </span><span class="s1">cache=</span><span class="s0">None, </span><span class="s1">key=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; Cache a function's result for speedy future evaluation 
 
    Considerations: 
        Trades memory for speed. 
        Only use on pure functions. 
 
    &gt;&gt;&gt; def add(x, y):  return x + y 
    &gt;&gt;&gt; add = memoize(add) 
 
    Or use as a decorator 
 
    &gt;&gt;&gt; @memoize 
    ... def add(x, y): 
    ...     return x + y 
 
    Use the ``cache`` keyword to provide a dict-like object as an initial cache 
 
    &gt;&gt;&gt; @memoize(cache={(1, 2): 3}) 
    ... def add(x, y): 
    ...     return x + y 
 
    Note that the above works as a decorator because ``memoize`` is curried. 
 
    It is also possible to provide a ``key(args, kwargs)`` function that 
    calculates keys used for the cache, which receives an ``args`` tuple and 
    ``kwargs`` dict as input, and must return a hashable value.  However, 
    the default key function should be sufficient most of the time. 
 
    &gt;&gt;&gt; # Use key function that ignores extraneous keyword arguments 
    &gt;&gt;&gt; @memoize(key=lambda args, kwargs: args) 
    ... def add(x, y, verbose=False): 
    ...     if verbose: 
    ...         print('Calculating %s + %s' % (x, y)) 
    ...     return x + y 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">cache </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">cache = {}</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">may_have_kwargs = has_keywords(func) </span><span class="s0">is not False</span>
        <span class="s5"># Is unary function (single arg, no variadic argument or keywords)?</span>
        <span class="s1">is_unary = is_arity(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">func)</span>
    <span class="s0">except </span><span class="s1">TypeError:  </span><span class="s5"># pragma: no cover</span>
        <span class="s1">may_have_kwargs = </span><span class="s0">True</span>
        <span class="s1">is_unary = </span><span class="s0">False</span>

    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">is_unary:</span>
            <span class="s0">def </span><span class="s1">key(args</span><span class="s0">, </span><span class="s1">kwargs):</span>
                <span class="s0">return </span><span class="s1">args[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">may_have_kwargs:</span>
            <span class="s0">def </span><span class="s1">key(args</span><span class="s0">, </span><span class="s1">kwargs):</span>
                <span class="s0">return </span><span class="s1">(</span>
                    <span class="s1">args </span><span class="s0">or None,</span>
                    <span class="s1">frozenset(kwargs.items()) </span><span class="s0">if </span><span class="s1">kwargs </span><span class="s0">else None,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">key(args</span><span class="s0">, </span><span class="s1">kwargs):</span>
                <span class="s0">return </span><span class="s1">args</span>

    <span class="s0">def </span><span class="s1">memof(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">k = key(args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">cache[k]</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Arguments to memoized function must be hashable&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">cache[k] = result = func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">memof.__name__ = func.__name__</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">pass</span>
    <span class="s1">memof.__doc__ = func.__doc__</span>
    <span class="s1">memof.__wrapped__ = func</span>
    <span class="s0">return </span><span class="s1">memof</span>


<span class="s0">class </span><span class="s1">Compose(object):</span>
    <span class="s4">&quot;&quot;&quot; A composition of functions 
 
    See Also: 
        compose 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = </span><span class="s2">'first'</span><span class="s0">, </span><span class="s2">'funcs'</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">funcs):</span>
        <span class="s1">funcs = tuple(reversed(funcs))</span>
        <span class="s1">self.first = funcs[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.funcs = funcs[</span><span class="s3">1</span><span class="s1">:]</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">ret = self.first(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">self.funcs:</span>
            <span class="s1">ret = f(ret)</span>
        <span class="s0">return </span><span class="s1">ret</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">return </span><span class="s1">self.first</span><span class="s0">, </span><span class="s1">self.funcs</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s1">self.first</span><span class="s0">, </span><span class="s1">self.funcs = state</span>

    <span class="s1">@instanceproperty(classval=__doc__)</span>
    <span class="s0">def </span><span class="s1">__doc__(self):</span>
        <span class="s0">def </span><span class="s1">composed_doc(*fs):</span>
            <span class="s4">&quot;&quot;&quot;Generate a docstring for the composition of fs. 
            &quot;&quot;&quot;</span>
            <span class="s0">if not </span><span class="s1">fs:</span>
                <span class="s5"># Argument name for the docstring.</span>
                <span class="s0">return </span><span class="s2">'*args, **kwargs'</span>

            <span class="s0">return </span><span class="s2">'{f}({g})'</span><span class="s1">.format(f=fs[</span><span class="s3">0</span><span class="s1">].__name__</span><span class="s0">, </span><span class="s1">g=composed_doc(*fs[</span><span class="s3">1</span><span class="s1">:]))</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s2">'lambda *args, **kwargs: ' </span><span class="s1">+</span>
                <span class="s1">composed_doc(*reversed((self.first</span><span class="s0">,</span><span class="s1">) + self.funcs))</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># One of our callables does not have a `__name__`, whatever.</span>
            <span class="s0">return </span><span class="s2">'A composition of functions'</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">__name__(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">'_of_'</span><span class="s1">.join(</span>
                <span class="s1">(f.__name__ </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">reversed((self.first</span><span class="s0">,</span><span class="s1">) + self.funcs))</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return </span><span class="s1">type(self).__name__</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">'{.__class__.__name__}{!r}'</span><span class="s1">.format(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">tuple(reversed((self.first</span><span class="s0">, </span><span class="s1">) + self.funcs)))</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Compose):</span>
            <span class="s0">return </span><span class="s1">other.first == self.first </span><span class="s0">and </span><span class="s1">other.funcs == self.funcs</span>
        <span class="s0">return </span><span class="s1">NotImplemented</span>

    <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s1">equality = self.__eq__(other)</span>
        <span class="s0">return </span><span class="s1">NotImplemented </span><span class="s0">if </span><span class="s1">equality </span><span class="s0">is </span><span class="s1">NotImplemented </span><span class="s0">else not </span><span class="s1">equality</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">return </span><span class="s1">hash(self.first) ^ hash(self.funcs)</span>

    <span class="s5"># Mimic the descriptor behavior of python functions.</span>
    <span class="s5"># i.e. let Compose be called as a method when bound to a class.</span>
    <span class="s5"># adapted from</span>
    <span class="s5"># docs.python.org/3/howto/descriptor.html#functions-and-methods</span>
    <span class="s0">def </span><span class="s1">__get__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">objtype=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self </span><span class="s0">if </span><span class="s1">obj </span><span class="s0">is None else </span><span class="s1">MethodType(self</span><span class="s0">, </span><span class="s1">obj)</span>

    <span class="s5"># introspection with Signature is only possible from py3.3+</span>
    <span class="s1">@instanceproperty</span>
    <span class="s0">def </span><span class="s1">__signature__(self):</span>
        <span class="s1">base = inspect.signature(self.first)</span>
        <span class="s1">last = inspect.signature(self.funcs[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">base.replace(return_annotation=last.return_annotation)</span>

    <span class="s1">__wrapped__ = instanceproperty(attrgetter(</span><span class="s2">'first'</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">compose(*funcs):</span>
    <span class="s4">&quot;&quot;&quot; Compose functions to operate in series. 
 
    Returns a function that applies other functions in sequence. 
 
    Functions are applied from right to left so that 
    ``compose(f, g, h)(x, y)`` is the same as ``f(g(h(x, y)))``. 
 
    If no arguments are provided, the identity function (f(x) = x) is returned. 
 
    &gt;&gt;&gt; inc = lambda i: i + 1 
    &gt;&gt;&gt; compose(str, inc)(3) 
    '4' 
 
    See Also: 
        compose_left 
        pipe 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">funcs:</span>
        <span class="s0">return </span><span class="s1">identity</span>
    <span class="s0">if </span><span class="s1">len(funcs) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">funcs[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">Compose(funcs)</span>


<span class="s0">def </span><span class="s1">compose_left(*funcs):</span>
    <span class="s4">&quot;&quot;&quot; Compose functions to operate in series. 
 
    Returns a function that applies other functions in sequence. 
 
    Functions are applied from left to right so that 
    ``compose_left(f, g, h)(x, y)`` is the same as ``h(g(f(x, y)))``. 
 
    If no arguments are provided, the identity function (f(x) = x) is returned. 
 
    &gt;&gt;&gt; inc = lambda i: i + 1 
    &gt;&gt;&gt; compose_left(inc, str)(3) 
    '4' 
 
    See Also: 
        compose 
        pipe 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">compose(*reversed(funcs))</span>


<span class="s0">def </span><span class="s1">pipe(data</span><span class="s0">, </span><span class="s1">*funcs):</span>
    <span class="s4">&quot;&quot;&quot; Pipe a value through a sequence of functions 
 
    I.e. ``pipe(data, f, g, h)`` is equivalent to ``h(g(f(data)))`` 
 
    We think of the value as progressing through a pipe of several 
    transformations, much like pipes in UNIX 
 
    ``$ cat data | f | g | h`` 
 
    &gt;&gt;&gt; double = lambda i: 2 * i 
    &gt;&gt;&gt; pipe(3, double, str) 
    '6' 
 
    See Also: 
        compose 
        compose_left 
        thread_first 
        thread_last 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">funcs:</span>
        <span class="s1">data = func(data)</span>
    <span class="s0">return </span><span class="s1">data</span>


<span class="s0">def </span><span class="s1">complement(func):</span>
    <span class="s4">&quot;&quot;&quot; Convert a predicate function to its logical complement. 
 
    In other words, return a function that, for inputs that normally 
    yield True, yields False, and vice-versa. 
 
    &gt;&gt;&gt; def iseven(n): return n % 2 == 0 
    &gt;&gt;&gt; isodd = complement(iseven) 
    &gt;&gt;&gt; iseven(2) 
    True 
    &gt;&gt;&gt; isodd(2) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">compose(not_</span><span class="s0">, </span><span class="s1">func)</span>


<span class="s0">class </span><span class="s1">juxt(object):</span>
    <span class="s4">&quot;&quot;&quot; Creates a function that calls several functions with the same arguments 
 
    Takes several functions and returns a function that applies its arguments 
    to each of those functions then returns a tuple of the results. 
 
    Name comes from juxtaposition: the fact of two things being seen or placed 
    close together with contrasting effect. 
 
    &gt;&gt;&gt; inc = lambda x: x + 1 
    &gt;&gt;&gt; double = lambda x: x * 2 
    &gt;&gt;&gt; juxt(inc, double)(10) 
    (11, 20) 
    &gt;&gt;&gt; juxt([inc, double])(10) 
    (11, 20) 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = [</span><span class="s2">'funcs'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*funcs):</span>
        <span class="s0">if </span><span class="s1">len(funcs) == </span><span class="s3">1 </span><span class="s0">and not </span><span class="s1">callable(funcs[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s1">funcs = funcs[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.funcs = tuple(funcs)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">tuple(func(*args</span><span class="s0">, </span><span class="s1">**kwargs) </span><span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.funcs)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">return </span><span class="s1">self.funcs</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s1">self.funcs = state</span>


<span class="s0">def </span><span class="s1">do(func</span><span class="s0">, </span><span class="s1">x):</span>
    <span class="s4">&quot;&quot;&quot; Runs ``func`` on ``x``, returns ``x`` 
 
    Because the results of ``func`` are not returned, only the side 
    effects of ``func`` are relevant. 
 
    Logging functions can be made by composing ``do`` with a storage function 
    like ``list.append`` or ``file.write`` 
 
    &gt;&gt;&gt; from toolz import compose 
    &gt;&gt;&gt; from toolz.curried import do 
 
    &gt;&gt;&gt; log = [] 
    &gt;&gt;&gt; inc = lambda x: x + 1 
    &gt;&gt;&gt; inc = compose(inc, do(log.append)) 
    &gt;&gt;&gt; inc(1) 
    2 
    &gt;&gt;&gt; inc(11) 
    12 
    &gt;&gt;&gt; log 
    [1, 11] 
    &quot;&quot;&quot;</span>
    <span class="s1">func(x)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s1">@curry</span>
<span class="s0">def </span><span class="s1">flip(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s4">&quot;&quot;&quot; Call the function call with the arguments flipped 
 
    This function is curried. 
 
    &gt;&gt;&gt; def div(a, b): 
    ...     return a // b 
    ... 
    &gt;&gt;&gt; flip(div, 2, 6) 
    3 
    &gt;&gt;&gt; div_by_two = flip(div, 2) 
    &gt;&gt;&gt; div_by_two(4) 
    2 
 
    This is particularly useful for built in functions and functions defined 
    in C extensions that accept positional only arguments. For example: 
    isinstance, issubclass. 
 
    &gt;&gt;&gt; data = [1, 'a', 'b', 2, 1.5, object(), 3] 
    &gt;&gt;&gt; only_ints = list(filter(flip(isinstance, int), data)) 
    &gt;&gt;&gt; only_ints 
    [1, 2, 3] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">func(b</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">def </span><span class="s1">return_none(exc):</span>
    <span class="s4">&quot;&quot;&quot; Returns None. 
    &quot;&quot;&quot;</span>
    <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">excepts(object):</span>
    <span class="s4">&quot;&quot;&quot;A wrapper around a function to catch exceptions and 
    dispatch to a handler. 
 
    This is like a functional try/except block, in the same way that 
    ifexprs are functional if/else blocks. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; excepting = excepts( 
    ...     ValueError, 
    ...     lambda a: [1, 2].index(a), 
    ...     lambda _: -1, 
    ... ) 
    &gt;&gt;&gt; excepting(1) 
    0 
    &gt;&gt;&gt; excepting(3) 
    -1 
 
    Multiple exceptions and default except clause. 
    &gt;&gt;&gt; excepting = excepts((IndexError, KeyError), lambda a: a[0]) 
    &gt;&gt;&gt; excepting([]) 
    &gt;&gt;&gt; excepting([1]) 
    1 
    &gt;&gt;&gt; excepting({}) 
    &gt;&gt;&gt; excepting({0: 1}) 
    1 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">exc</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">handler=return_none):</span>
        <span class="s1">self.exc = exc</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.handler = handler</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">except </span><span class="s1">self.exc </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">return </span><span class="s1">self.handler(e)</span>

    <span class="s1">@instanceproperty(classval=__doc__)</span>
    <span class="s0">def </span><span class="s1">__doc__(self):</span>
        <span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>

        <span class="s1">exc = self.exc</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">exc_name = </span><span class="s2">'(%s)' </span><span class="s1">% </span><span class="s2">', '</span><span class="s1">.join(</span>
                    <span class="s1">map(attrgetter(</span><span class="s2">'__name__'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exc)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">exc_name = exc.__name__</span>

            <span class="s0">return </span><span class="s1">dedent(</span>
                <span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
                </span><span class="s2">A wrapper around {inst.func.__name__!r} that will except: 
                {exc} 
                and handle any exceptions with {inst.handler.__name__!r}. 
 
                Docs for {inst.func.__name__!r}: 
                {inst.func.__doc__} 
 
                Docs for {inst.handler.__name__!r}: 
                {inst.handler.__doc__} 
                &quot;&quot;&quot;</span>
            <span class="s1">).format(</span>
                <span class="s1">inst=self</span><span class="s0">,</span>
                <span class="s1">exc=exc_name</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return </span><span class="s1">type(self).__doc__</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">__name__(self):</span>
        <span class="s1">exc = self.exc</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">exc_name = </span><span class="s2">'_or_'</span><span class="s1">.join(map(attrgetter(</span><span class="s2">'__name__'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exc))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">exc_name = exc.__name__</span>
            <span class="s0">return </span><span class="s2">'%s_excepting_%s' </span><span class="s1">% (self.func.__name__</span><span class="s0">, </span><span class="s1">exc_name)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return </span><span class="s2">'excepting'</span>


<span class="s0">def </span><span class="s1">_check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">builtin_func</span><span class="s0">, </span><span class="s1">*builtin_args):</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">sigspec = inspect.signature(func)</span>
        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">sigspec = e</span>
    <span class="s0">if </span><span class="s1">isinstance(sigspec</span><span class="s0">, </span><span class="s1">ValueError):</span>
        <span class="s0">return None, </span><span class="s1">builtin_func(*builtin_args)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(sigspec</span><span class="s0">, </span><span class="s1">inspect.Signature):</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">func </span><span class="s0">in </span><span class="s1">_sigs.signatures</span>
            <span class="s0">and </span><span class="s1">((</span>
                <span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">'__signature__'</span><span class="s1">)</span>
                <span class="s0">and </span><span class="s1">hasattr(func.__signature__</span><span class="s0">, </span><span class="s2">'__get__'</span><span class="s1">)</span>
            <span class="s1">))</span>
        <span class="s1">):</span>
            <span class="s1">val = builtin_func(*builtin_args)</span>
            <span class="s0">return None, </span><span class="s1">val</span>
        <span class="s0">return None, False</span>
    <span class="s0">return </span><span class="s1">sigspec</span><span class="s0">, None</span>


<span class="s0">if </span><span class="s1">PYPY:  </span><span class="s5"># pragma: no cover</span>
    <span class="s1">_check_sigspec_orig = _check_sigspec</span>

    <span class="s0">def </span><span class="s1">_check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">builtin_func</span><span class="s0">, </span><span class="s1">*builtin_args):</span>
        <span class="s5"># PyPy may lie, so use our registry for builtins instead</span>
        <span class="s0">if </span><span class="s1">func </span><span class="s0">in </span><span class="s1">_sigs.signatures:</span>
            <span class="s1">val = builtin_func(*builtin_args)</span>
            <span class="s0">return None, </span><span class="s1">val</span>
        <span class="s0">return </span><span class="s1">_check_sigspec_orig(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">builtin_func</span><span class="s0">, </span><span class="s1">*builtin_args)</span>


<span class="s1">_check_sigspec.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Private function to aid in introspection compatibly across Python versions. 
 
If a callable doesn't have a signature (Python 3) or an argspec (Python 2), 
the signature registry in toolz._signatures is used. 
&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">num_required_args(func</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._num_required_args</span><span class="s0">,</span>
                                 <span class="s1">func)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s0">return </span><span class="s1">sum(</span><span class="s3">1 </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sigspec.parameters.values()</span>
               <span class="s0">if </span><span class="s1">p.default </span><span class="s0">is </span><span class="s1">p.empty</span>
               <span class="s0">and </span><span class="s1">p.kind </span><span class="s0">in </span><span class="s1">(p.POSITIONAL_OR_KEYWORD</span><span class="s0">, </span><span class="s1">p.POSITIONAL_ONLY))</span>


<span class="s0">def </span><span class="s1">has_varargs(func</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._has_varargs</span><span class="s0">, </span><span class="s1">func)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s0">return </span><span class="s1">any(p.kind == p.VAR_POSITIONAL</span>
               <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sigspec.parameters.values())</span>


<span class="s0">def </span><span class="s1">has_keywords(func</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._has_keywords</span><span class="s0">, </span><span class="s1">func)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s0">return </span><span class="s1">any(p.default </span><span class="s0">is not </span><span class="s1">p.empty</span>
               <span class="s0">or </span><span class="s1">p.kind </span><span class="s0">in </span><span class="s1">(p.KEYWORD_ONLY</span><span class="s0">, </span><span class="s1">p.VAR_KEYWORD)</span>
               <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sigspec.parameters.values())</span>


<span class="s0">def </span><span class="s1">is_valid_args(func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._is_valid_args</span><span class="s0">,</span>
                                 <span class="s1">func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">sigspec.bind(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">is_partial_args(func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._is_partial_args</span><span class="s0">,</span>
                                 <span class="s1">func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">sigspec.bind_partial(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">is_arity(n</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">sigspec=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; Does a function have only n positional arguments? 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def f(x): 
    ...     return x 
    &gt;&gt;&gt; is_arity(1, f) 
    True 
    &gt;&gt;&gt; def g(x, y=1): 
    ...     return x + y 
    &gt;&gt;&gt; is_arity(1, g) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">sigspec</span><span class="s0">, </span><span class="s1">rv = _check_sigspec(sigspec</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">_sigs._is_arity</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">func)</span>
    <span class="s0">if </span><span class="s1">sigspec </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">rv</span>
    <span class="s1">num = num_required_args(func</span><span class="s0">, </span><span class="s1">sigspec)</span>
    <span class="s0">if </span><span class="s1">num </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">num = num == n</span>
        <span class="s0">if not </span><span class="s1">num:</span>
            <span class="s0">return False</span>
    <span class="s1">varargs = has_varargs(func</span><span class="s0">, </span><span class="s1">sigspec)</span>
    <span class="s0">if </span><span class="s1">varargs:</span>
        <span class="s0">return False</span>
    <span class="s1">keywords = has_keywords(func</span><span class="s0">, </span><span class="s1">sigspec)</span>
    <span class="s0">if </span><span class="s1">keywords:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">num </span><span class="s0">is None or </span><span class="s1">varargs </span><span class="s0">is None or </span><span class="s1">keywords </span><span class="s0">is None</span><span class="s1">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">return None</span>
    <span class="s0">return True</span>


<span class="s1">num_required_args.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Number of required positional arguments 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def f(x, y, z=3): 
    ...     return x + y + z 
    &gt;&gt;&gt; num_required_args(f) 
    2 
    &gt;&gt;&gt; def g(*args, **kwargs): 
    ...     pass 
    &gt;&gt;&gt; num_required_args(g) 
    0 
    &quot;&quot;&quot;</span>

<span class="s1">has_varargs.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Does a function have variadic positional arguments? 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def f(*args): 
    ...    return args 
    &gt;&gt;&gt; has_varargs(f) 
    True 
    &gt;&gt;&gt; def g(**kwargs): 
    ...    return kwargs 
    &gt;&gt;&gt; has_varargs(g) 
    False 
    &quot;&quot;&quot;</span>

<span class="s1">has_keywords.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Does a function have keyword arguments? 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def f(x, y=0): 
    ...     return x + y 
 
    &gt;&gt;&gt; has_keywords(f) 
    True 
    &quot;&quot;&quot;</span>

<span class="s1">is_valid_args.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Is ``func(*args, **kwargs)`` a valid function call? 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def add(x, y): 
    ...     return x + y 
 
    &gt;&gt;&gt; is_valid_args(add, (1,), {}) 
    False 
    &gt;&gt;&gt; is_valid_args(add, (1, 2), {}) 
    True 
    &gt;&gt;&gt; is_valid_args(map, (), {}) 
    False 
 
    **Implementation notes** 
    Python 2 relies on ``inspect.getargspec``, which only works for 
    user-defined functions.  Python 3 uses ``inspect.signature``, which 
    works for many more types of callables. 
 
    Many builtins in the standard library are also supported. 
    &quot;&quot;&quot;</span>

<span class="s1">is_partial_args.__doc__ = </span><span class="s2">&quot;&quot;&quot; </span><span class="s0">\ 
</span><span class="s2">Can partial(func, *args, **kwargs)(*args2, **kwargs2) be a valid call? 
 
    Returns True *only* if the call is valid or if it is possible for the 
    call to become valid by adding more positional or keyword arguments. 
 
    This function relies on introspection and does not call the function. 
    Returns None if validity can't be determined. 
 
    &gt;&gt;&gt; def add(x, y): 
    ...     return x + y 
 
    &gt;&gt;&gt; is_partial_args(add, (1,), {}) 
    True 
    &gt;&gt;&gt; is_partial_args(add, (1, 2), {}) 
    True 
    &gt;&gt;&gt; is_partial_args(add, (1, 2, 3), {}) 
    False 
    &gt;&gt;&gt; is_partial_args(map, (), {}) 
    True 
 
    **Implementation notes** 
    Python 2 relies on ``inspect.getargspec``, which only works for 
    user-defined functions.  Python 3 uses ``inspect.signature``, which 
    works for many more types of callables. 
 
    Many builtins in the standard library are also supported. 
    &quot;&quot;&quot;</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_signatures </span><span class="s0">as </span><span class="s1">_sigs</span>
</pre>
</body>
</html>