<html>
<head>
<title>mgcv_cubic_splines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mgcv_cubic_splines.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2014 GDF Suez, http://www.gdfsuez.com/</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># R package 'mgcv' compatible cubic spline basis functions</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ = [</span><span class="s2">&quot;cr&quot;</span><span class="s3">, </span><span class="s2">&quot;cc&quot;</span><span class="s3">, </span><span class="s2">&quot;te&quot;</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">patsy.util </span><span class="s3">import </span><span class="s1">(have_pandas</span><span class="s3">, </span><span class="s1">atleast_2d_column_default</span><span class="s3">,</span>
                        <span class="s1">no_pickling</span><span class="s3">, </span><span class="s1">assert_no_pickling</span><span class="s3">, </span><span class="s1">safe_string_eq)</span>
<span class="s3">from </span><span class="s1">patsy.state </span><span class="s3">import </span><span class="s1">stateful_transform</span>

<span class="s3">if </span><span class="s1">have_pandas:</span>
    <span class="s3">import </span><span class="s1">pandas</span>


<span class="s3">def </span><span class="s1">_get_natural_f(knots):</span>
    <span class="s4">&quot;&quot;&quot;Returns mapping of natural cubic spline values to 2nd derivatives. 
 
    .. note:: See 'Generalized Additive Models', Simon N. Wood, 2006, pp 145-146 
 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :return: A 2-d array mapping natural cubic spline values at 
     knots to second derivatives. 
 
    :raise ImportError: if scipy is not found, required for 
     ``linalg.solve_banded()`` 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
    <span class="s3">except </span><span class="s1">ImportError: </span><span class="s0"># pragma: no cover</span>
        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s2">&quot;Cubic spline functionality requires scipy.&quot;</span><span class="s1">)</span>

    <span class="s1">h = knots[</span><span class="s5">1</span><span class="s1">:] - knots[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">diag = (h[:-</span><span class="s5">1</span><span class="s1">] + h[</span><span class="s5">1</span><span class="s1">:]) / </span><span class="s5">3.</span>
    <span class="s1">ul_diag = h[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] / </span><span class="s5">6.</span>
    <span class="s1">banded_b = np.array([np.r_[</span><span class="s5">0.</span><span class="s3">, </span><span class="s1">ul_diag]</span><span class="s3">, </span><span class="s1">diag</span><span class="s3">, </span><span class="s1">np.r_[ul_diag</span><span class="s3">, </span><span class="s5">0.</span><span class="s1">]])</span>
    <span class="s1">d = np.zeros((knots.size - </span><span class="s5">2</span><span class="s3">, </span><span class="s1">knots.size))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(knots.size - </span><span class="s5">2</span><span class="s1">):</span>
        <span class="s1">d[i</span><span class="s3">, </span><span class="s1">i] = </span><span class="s5">1. </span><span class="s1">/ h[i]</span>
        <span class="s1">d[i</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">2</span><span class="s1">] = </span><span class="s5">1. </span><span class="s1">/ h[i + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">d[i</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">] = - d[i</span><span class="s3">, </span><span class="s1">i] - d[i</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">2</span><span class="s1">]</span>

    <span class="s1">fm = linalg.solve_banded((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">banded_b</span><span class="s3">, </span><span class="s1">d)</span>

    <span class="s3">return </span><span class="s1">np.vstack([np.zeros(knots.size)</span><span class="s3">, </span><span class="s1">fm</span><span class="s3">, </span><span class="s1">np.zeros(knots.size)])</span>


<span class="s0"># Cyclic Cubic Regression Splines</span>


<span class="s3">def </span><span class="s1">_map_cyclic(x</span><span class="s3">, </span><span class="s1">lbound</span><span class="s3">, </span><span class="s1">ubound):</span>
    <span class="s4">&quot;&quot;&quot;Maps values into the interval [lbound, ubound] in a cyclic fashion. 
 
    :param x: The 1-d array values to be mapped. 
    :param lbound: The lower bound of the interval. 
    :param ubound: The upper bound of the interval. 
    :return: A new 1-d array containing mapped x values. 
 
    :raise ValueError: if lbound &gt;= ubound. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">lbound &gt;= ubound:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid argument: lbound (%r) should be &quot;</span>
                         <span class="s2">&quot;less than ubound (%r).&quot;</span>
                         <span class="s1">% (lbound</span><span class="s3">, </span><span class="s1">ubound))</span>

    <span class="s1">x = np.copy(x)</span>
    <span class="s1">x[x &gt; ubound] = lbound + (x[x &gt; ubound] - ubound) % (ubound - lbound)</span>
    <span class="s1">x[x &lt; lbound] = ubound - (lbound - x[x &lt; lbound]) % (ubound - lbound)</span>

    <span class="s3">return </span><span class="s1">x</span>


<span class="s3">def </span><span class="s1">test__map_cyclic():</span>
    <span class="s1">x = np.array([</span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">2.6</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">4.4</span><span class="s3">, </span><span class="s5">10.7</span><span class="s1">])</span>
    <span class="s1">x_orig = np.copy(x)</span>
    <span class="s1">expected_mapped_x = np.array([</span><span class="s5">3.0</span><span class="s3">, </span><span class="s5">2.6</span><span class="s3">, </span><span class="s5">3.1</span><span class="s3">, </span><span class="s5">2.9</span><span class="s3">, </span><span class="s5">3.2</span><span class="s1">])</span>
    <span class="s1">mapped_x = _map_cyclic(x</span><span class="s3">, </span><span class="s5">2.1</span><span class="s3">, </span><span class="s5">3.6</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.allclose(x</span><span class="s3">, </span><span class="s1">x_orig)</span>
    <span class="s3">assert </span><span class="s1">np.allclose(mapped_x</span><span class="s3">, </span><span class="s1">expected_mapped_x)</span>


<span class="s3">def </span><span class="s1">test__map_cyclic_errors():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s1">x = np.linspace(</span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">5.7</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_map_cyclic</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">3.6</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_map_cyclic</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">4.5</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_get_cyclic_f(knots):</span>
    <span class="s4">&quot;&quot;&quot;Returns mapping of cyclic cubic spline values to 2nd derivatives. 
 
    .. note:: See 'Generalized Additive Models', Simon N. Wood, 2006, pp 146-147 
 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :return: A 2-d array mapping cyclic cubic spline values at 
     knots to second derivatives. 
    &quot;&quot;&quot;</span>
    <span class="s1">h = knots[</span><span class="s5">1</span><span class="s1">:] - knots[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">n = knots.size - </span><span class="s5">1</span>
    <span class="s1">b = np.zeros((n</span><span class="s3">, </span><span class="s1">n))</span>
    <span class="s1">d = np.zeros((n</span><span class="s3">, </span><span class="s1">n))</span>

    <span class="s1">b[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = (h[n - </span><span class="s5">1</span><span class="s1">] + h[</span><span class="s5">0</span><span class="s1">]) / </span><span class="s5">3.</span>
    <span class="s1">b[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n - </span><span class="s5">1</span><span class="s1">] = h[n - </span><span class="s5">1</span><span class="s1">] / </span><span class="s5">6.</span>
    <span class="s1">b[n - </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = h[n - </span><span class="s5">1</span><span class="s1">] / </span><span class="s5">6.</span>

    <span class="s1">d[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1. </span><span class="s1">/ h[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1. </span><span class="s1">/ h[n - </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">d[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n - </span><span class="s5">1</span><span class="s1">] = </span><span class="s5">1. </span><span class="s1">/ h[n - </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">d[n - </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1. </span><span class="s1">/ h[n - </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n):</span>
        <span class="s1">b[i</span><span class="s3">, </span><span class="s1">i] = (h[i - </span><span class="s5">1</span><span class="s1">] + h[i]) / </span><span class="s5">3.</span>
        <span class="s1">b[i</span><span class="s3">, </span><span class="s1">i - </span><span class="s5">1</span><span class="s1">] = h[i - </span><span class="s5">1</span><span class="s1">] / </span><span class="s5">6.</span>
        <span class="s1">b[i - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">i] = h[i - </span><span class="s5">1</span><span class="s1">] / </span><span class="s5">6.</span>

        <span class="s1">d[i</span><span class="s3">, </span><span class="s1">i] = -</span><span class="s5">1. </span><span class="s1">/ h[i - </span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1. </span><span class="s1">/ h[i]</span>
        <span class="s1">d[i</span><span class="s3">, </span><span class="s1">i - </span><span class="s5">1</span><span class="s1">] = </span><span class="s5">1. </span><span class="s1">/ h[i - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">d[i - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">i] = </span><span class="s5">1. </span><span class="s1">/ h[i - </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">return </span><span class="s1">np.linalg.solve(b</span><span class="s3">, </span><span class="s1">d)</span>


<span class="s0"># Tensor Product</span>


<span class="s3">def </span><span class="s1">_row_tensor_product(dms):</span>
    <span class="s4">&quot;&quot;&quot;Computes row-wise tensor product of given arguments. 
 
    .. note:: Custom algorithm to precisely match what is done in 'mgcv', 
    in particular look out for order of result columns! 
    For reference implementation see 'mgcv' source code, 
    file 'mat.c', mgcv_tensor_mm(), l.62 
 
    :param dms: A sequence of 2-d arrays (marginal design matrices). 
    :return: The 2-d array row-wise tensor product of given arguments. 
 
    :raise ValueError: if argument sequence is empty, does not contain only 
     2-d arrays or if the arrays number of rows does not match. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len(dms) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Tensor product arrays sequence should not be empty.&quot;</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">dm </span><span class="s3">in </span><span class="s1">dms:</span>
        <span class="s3">if </span><span class="s1">dm.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Tensor product arguments should be 2-d arrays.&quot;</span><span class="s1">)</span>

    <span class="s1">tp_nrows = dms[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">tp_ncols = </span><span class="s5">1</span>
    <span class="s3">for </span><span class="s1">dm </span><span class="s3">in </span><span class="s1">dms:</span>
        <span class="s3">if </span><span class="s1">dm.shape[</span><span class="s5">0</span><span class="s1">] != tp_nrows:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Tensor product arguments should have &quot;</span>
                             <span class="s2">&quot;same number of rows.&quot;</span><span class="s1">)</span>
        <span class="s1">tp_ncols *= dm.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">tp = np.zeros((tp_nrows</span><span class="s3">, </span><span class="s1">tp_ncols))</span>
    <span class="s1">tp[:</span><span class="s3">, </span><span class="s1">-dms[-</span><span class="s5">1</span><span class="s1">].shape[</span><span class="s5">1</span><span class="s1">]:] = dms[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">filled_tp_ncols = dms[-</span><span class="s5">1</span><span class="s1">].shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">for </span><span class="s1">dm </span><span class="s3">in </span><span class="s1">dms[-</span><span class="s5">2</span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">p = - filled_tp_ncols * dm.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(dm.shape[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s1">xj = dm[:</span><span class="s3">, </span><span class="s1">j]</span>
            <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">range(-filled_tp_ncols</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s1">tp[:</span><span class="s3">, </span><span class="s1">p] = tp[:</span><span class="s3">, </span><span class="s1">t] * xj</span>
                <span class="s1">p += </span><span class="s5">1</span>
        <span class="s1">filled_tp_ncols *= dm.shape[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">return </span><span class="s1">tp</span>


<span class="s3">def </span><span class="s1">test__row_tensor_product_errors():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_row_tensor_product</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_row_tensor_product</span><span class="s3">, </span><span class="s1">[np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_row_tensor_product</span><span class="s3">,</span>
                  <span class="s1">[np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_row_tensor_product</span><span class="s3">,</span>
                  <span class="s1">[np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">13</span><span class="s1">).reshape((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span><span class="s3">,</span>
                   <span class="s1">np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">13</span><span class="s1">).reshape((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))])</span>


<span class="s3">def </span><span class="s1">test__row_tensor_product():</span>
    <span class="s0"># Testing cases where main input array should not be modified</span>
    <span class="s1">dm1 = np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">17</span><span class="s1">).reshape((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(_row_tensor_product([dm1])</span><span class="s3">, </span><span class="s1">dm1)</span>
    <span class="s1">ones = np.ones(</span><span class="s5">4</span><span class="s1">).reshape((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">tp1 = _row_tensor_product([ones</span><span class="s3">, </span><span class="s1">dm1])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp1</span><span class="s3">, </span><span class="s1">dm1)</span>
    <span class="s1">tp2 = _row_tensor_product([dm1</span><span class="s3">, </span><span class="s1">ones])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp2</span><span class="s3">, </span><span class="s1">dm1)</span>

    <span class="s0"># Testing cases where main input array should be scaled</span>
    <span class="s1">twos = </span><span class="s5">2 </span><span class="s1">* ones</span>
    <span class="s1">tp3 = _row_tensor_product([twos</span><span class="s3">, </span><span class="s1">dm1])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp3</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* dm1)</span>
    <span class="s1">tp4 = _row_tensor_product([dm1</span><span class="s3">, </span><span class="s1">twos])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp4</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* dm1)</span>

    <span class="s0"># Testing main cases</span>
    <span class="s1">dm2 = np.array([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">dm3 = np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">expected_tp5 = np.array([[</span><span class="s5">1</span><span class="s3">,  </span><span class="s5">2</span><span class="s3">,  </span><span class="s5">3</span><span class="s3">,  </span><span class="s5">2</span><span class="s3">,  </span><span class="s5">4</span><span class="s3">,  </span><span class="s5">6</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">[</span><span class="s5">4</span><span class="s3">,  </span><span class="s5">5</span><span class="s3">,  </span><span class="s5">6</span><span class="s3">,  </span><span class="s5">8</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">12</span><span class="s1">]])</span>
    <span class="s1">tp5 = _row_tensor_product([dm2</span><span class="s3">, </span><span class="s1">dm3])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp5</span><span class="s3">, </span><span class="s1">expected_tp5)</span>
    <span class="s1">expected_tp6 = np.array([[</span><span class="s5">1</span><span class="s3">,  </span><span class="s5">2</span><span class="s3">,  </span><span class="s5">2</span><span class="s3">,  </span><span class="s5">4</span><span class="s3">,  </span><span class="s5">3</span><span class="s3">,  </span><span class="s5">6</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">[</span><span class="s5">4</span><span class="s3">,  </span><span class="s5">8</span><span class="s3">,  </span><span class="s5">5</span><span class="s3">, </span><span class="s5">10</span><span class="s3">,  </span><span class="s5">6</span><span class="s3">, </span><span class="s5">12</span><span class="s1">]])</span>
    <span class="s1">tp6 = _row_tensor_product([dm3</span><span class="s3">, </span><span class="s1">dm2])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(tp6</span><span class="s3">, </span><span class="s1">expected_tp6)</span>


<span class="s0"># Common code</span>


<span class="s3">def </span><span class="s1">_find_knots_lower_bounds(x</span><span class="s3">, </span><span class="s1">knots):</span>
    <span class="s4">&quot;&quot;&quot;Finds knots lower bounds for given values. 
 
    Returns an array of indices ``I`` such that 
    ``0 &lt;= I[i] &lt;= knots.size - 2`` for all ``i`` 
    and 
    ``knots[I[i]] &lt; x[i] &lt;= knots[I[i] + 1]`` if 
    ``np.min(knots) &lt; x[i] &lt;= np.max(knots)``, 
    ``I[i] = 0`` if ``x[i] &lt;= np.min(knots)`` 
    ``I[i] = knots.size - 2`` if ``np.max(knots) &lt; x[i]`` 
 
    :param x: The 1-d array values whose knots lower bounds are to be found. 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :return: An array of knots lower bounds indices. 
    &quot;&quot;&quot;</span>
    <span class="s1">lb = np.searchsorted(knots</span><span class="s3">, </span><span class="s1">x) - </span><span class="s5">1</span>

    <span class="s0"># I[i] = 0 for x[i] &lt;= np.min(knots)</span>
    <span class="s1">lb[lb == -</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0</span>

    <span class="s0"># I[i] = knots.size - 2 for x[i] &gt; np.max(knots)</span>
    <span class="s1">lb[lb == knots.size - </span><span class="s5">1</span><span class="s1">] = knots.size - </span><span class="s5">2</span>

    <span class="s3">return </span><span class="s1">lb</span>


<span class="s3">def </span><span class="s1">_compute_base_functions(x</span><span class="s3">, </span><span class="s1">knots):</span>
    <span class="s4">&quot;&quot;&quot;Computes base functions used for building cubic splines basis. 
 
    .. note:: See 'Generalized Additive Models', Simon N. Wood, 2006, p. 146 
      and for the special treatment of ``x`` values outside ``knots`` range 
      see 'mgcv' source code, file 'mgcv.c', function 'crspl()', l.249 
 
    :param x: The 1-d array values for which base functions should be computed. 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :return: 4 arrays corresponding to the 4 base functions ajm, ajp, cjm, cjp 
     + the 1-d array of knots lower bounds indices corresponding to 
     the given ``x`` values. 
    &quot;&quot;&quot;</span>
    <span class="s1">j = _find_knots_lower_bounds(x</span><span class="s3">, </span><span class="s1">knots)</span>

    <span class="s1">h = knots[</span><span class="s5">1</span><span class="s1">:] - knots[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">hj = h[j]</span>
    <span class="s1">xj1_x = knots[j + </span><span class="s5">1</span><span class="s1">] - x</span>
    <span class="s1">x_xj = x - knots[j]</span>

    <span class="s1">ajm = xj1_x / hj</span>
    <span class="s1">ajp = x_xj / hj</span>

    <span class="s1">cjm_3 = xj1_x * xj1_x * xj1_x / (</span><span class="s5">6. </span><span class="s1">* hj)</span>
    <span class="s1">cjm_3[x &gt; np.max(knots)] = </span><span class="s5">0.</span>
    <span class="s1">cjm_1 = hj * xj1_x / </span><span class="s5">6.</span>
    <span class="s1">cjm = cjm_3 - cjm_1</span>

    <span class="s1">cjp_3 = x_xj * x_xj * x_xj / (</span><span class="s5">6. </span><span class="s1">* hj)</span>
    <span class="s1">cjp_3[x &lt; np.min(knots)] = </span><span class="s5">0.</span>
    <span class="s1">cjp_1 = hj * x_xj / </span><span class="s5">6.</span>
    <span class="s1">cjp = cjp_3 - cjp_1</span>

    <span class="s3">return </span><span class="s1">ajm</span><span class="s3">, </span><span class="s1">ajp</span><span class="s3">, </span><span class="s1">cjm</span><span class="s3">, </span><span class="s1">cjp</span><span class="s3">, </span><span class="s1">j</span>


<span class="s3">def </span><span class="s1">_absorb_constraints(design_matrix</span><span class="s3">, </span><span class="s1">constraints):</span>
    <span class="s4">&quot;&quot;&quot;Absorb model parameters constraints into the design matrix. 
 
    :param design_matrix: The (2-d array) initial design matrix. 
    :param constraints: The 2-d array defining initial model parameters 
     (``betas``) constraints (``np.dot(constraints, betas) = 0``). 
    :return: The new design matrix with absorbed parameters constraints. 
 
    :raise ImportError: if scipy is not found, used for ``scipy.linalg.qr()`` 
      which is cleaner than numpy's version requiring a call like 
      ``qr(..., mode='complete')`` to get a full QR decomposition. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
    <span class="s3">except </span><span class="s1">ImportError: </span><span class="s0"># pragma: no cover</span>
        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s2">&quot;Cubic spline functionality requires scipy.&quot;</span><span class="s1">)</span>

    <span class="s1">m = constraints.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">q</span><span class="s3">, </span><span class="s1">r = linalg.qr(np.transpose(constraints))</span>

    <span class="s3">return </span><span class="s1">np.dot(design_matrix</span><span class="s3">, </span><span class="s1">q[:</span><span class="s3">, </span><span class="s1">m:])</span>


<span class="s3">def </span><span class="s1">_get_free_crs_dmatrix(x</span><span class="s3">, </span><span class="s1">knots</span><span class="s3">, </span><span class="s1">cyclic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Builds an unconstrained cubic regression spline design matrix. 
 
    Returns design matrix with dimensions ``len(x) x n`` 
    for a cubic regression spline smoother 
    where 
     - ``n = len(knots)`` for natural CRS 
     - ``n = len(knots) - 1`` for cyclic CRS 
 
    .. note:: See 'Generalized Additive Models', Simon N. Wood, 2006, p. 145 
 
    :param x: The 1-d array values. 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :param cyclic: Indicates whether used cubic regression splines should 
     be cyclic or not. Default is ``False``. 
    :return: The (2-d array) design matrix. 
    &quot;&quot;&quot;</span>
    <span class="s1">n = knots.size</span>
    <span class="s3">if </span><span class="s1">cyclic:</span>
        <span class="s1">x = _map_cyclic(x</span><span class="s3">, </span><span class="s1">min(knots)</span><span class="s3">, </span><span class="s1">max(knots))</span>
        <span class="s1">n -= </span><span class="s5">1</span>

    <span class="s1">ajm</span><span class="s3">, </span><span class="s1">ajp</span><span class="s3">, </span><span class="s1">cjm</span><span class="s3">, </span><span class="s1">cjp</span><span class="s3">, </span><span class="s1">j = _compute_base_functions(x</span><span class="s3">, </span><span class="s1">knots)</span>

    <span class="s1">j1 = j + </span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">cyclic:</span>
        <span class="s1">j1[j1 == n] = </span><span class="s5">0</span>

    <span class="s1">i = np.identity(n)</span>

    <span class="s3">if </span><span class="s1">cyclic:</span>
        <span class="s1">f = _get_cyclic_f(knots)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">f = _get_natural_f(knots)</span>

    <span class="s1">dmt = ajm * i[j</span><span class="s3">, </span><span class="s1">:].T + ajp * i[j1</span><span class="s3">, </span><span class="s1">:].T + \</span>
        <span class="s1">cjm * f[j</span><span class="s3">, </span><span class="s1">:].T + cjp * f[j1</span><span class="s3">, </span><span class="s1">:].T</span>

    <span class="s3">return </span><span class="s1">dmt.T</span>


<span class="s3">def </span><span class="s1">_get_crs_dmatrix(x</span><span class="s3">, </span><span class="s1">knots</span><span class="s3">, </span><span class="s1">constraints=</span><span class="s3">None, </span><span class="s1">cyclic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Builds a cubic regression spline design matrix. 
 
    Returns design matrix with dimensions len(x) x n 
    where: 
     - ``n = len(knots) - nrows(constraints)`` for natural CRS 
     - ``n = len(knots) - nrows(constraints) - 1`` for cyclic CRS 
    for a cubic regression spline smoother 
 
    :param x: The 1-d array values. 
    :param knots: The 1-d array knots used for cubic spline parametrization, 
     must be sorted in ascending order. 
    :param constraints: The 2-d array defining model parameters (``betas``) 
     constraints (``np.dot(constraints, betas) = 0``). 
    :param cyclic: Indicates whether used cubic regression splines should 
     be cyclic or not. Default is ``False``. 
    :return: The (2-d array) design matrix. 
    &quot;&quot;&quot;</span>
    <span class="s1">dm = _get_free_crs_dmatrix(x</span><span class="s3">, </span><span class="s1">knots</span><span class="s3">, </span><span class="s1">cyclic)</span>
    <span class="s3">if </span><span class="s1">constraints </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">dm = _absorb_constraints(dm</span><span class="s3">, </span><span class="s1">constraints)</span>

    <span class="s3">return </span><span class="s1">dm</span>


<span class="s3">def </span><span class="s1">_get_te_dmatrix(design_matrices</span><span class="s3">, </span><span class="s1">constraints=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Builds tensor product design matrix, given the marginal design matrices. 
 
    :param design_matrices: A sequence of 2-d arrays (marginal design matrices). 
    :param constraints: The 2-d array defining model parameters (``betas``) 
     constraints (``np.dot(constraints, betas) = 0``). 
    :return: The (2-d array) design matrix. 
    &quot;&quot;&quot;</span>
    <span class="s1">dm = _row_tensor_product(design_matrices)</span>
    <span class="s3">if </span><span class="s1">constraints </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">dm = _absorb_constraints(dm</span><span class="s3">, </span><span class="s1">constraints)</span>

    <span class="s3">return </span><span class="s1">dm</span>


<span class="s0"># Stateful Transforms</span>


<span class="s3">def </span><span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s1">n_inner_knots=</span><span class="s3">None, </span><span class="s1">inner_knots=</span><span class="s3">None,</span>
                              <span class="s1">lower_bound=</span><span class="s3">None, </span><span class="s1">upper_bound=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Gets all knots locations with lower and upper exterior knots included. 
 
    If needed, inner knots are computed as equally spaced quantiles of the 
    input data falling between given lower and upper bounds. 
 
    :param x: The 1-d array data values. 
    :param n_inner_knots: Number of inner knots to compute. 
    :param inner_knots: Provided inner knots if any. 
    :param lower_bound: The lower exterior knot location. If unspecified, the 
     minimum of ``x`` values is used. 
    :param upper_bound: The upper exterior knot location. If unspecified, the 
     maximum of ``x`` values is used. 
    :return: The array of ``n_inner_knots + 2`` distinct knots. 
 
    :raise ValueError: for various invalid parameters sets or if unable to 
     compute ``n_inner_knots + 2`` distinct knots. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">lower_bound </span><span class="s3">is None and </span><span class="s1">x.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot set lower exterior knot location: empty &quot;</span>
                         <span class="s2">&quot;input data and lower_bound not specified.&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">lower_bound </span><span class="s3">is None and </span><span class="s1">x.size != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">lower_bound = np.min(x)</span>

    <span class="s3">if </span><span class="s1">upper_bound </span><span class="s3">is None and </span><span class="s1">x.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot set upper exterior knot location: empty &quot;</span>
                         <span class="s2">&quot;input data and upper_bound not specified.&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">upper_bound </span><span class="s3">is None and </span><span class="s1">x.size != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">upper_bound = np.max(x)</span>

    <span class="s3">if </span><span class="s1">upper_bound &lt; lower_bound:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;lower_bound &gt; upper_bound (%r &gt; %r)&quot;</span>
                         <span class="s1">% (lower_bound</span><span class="s3">, </span><span class="s1">upper_bound))</span>

    <span class="s3">if </span><span class="s1">inner_knots </span><span class="s3">is None and </span><span class="s1">n_inner_knots </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">n_inner_knots &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid requested number of inner knots: %r&quot;</span>
                             <span class="s1">% (n_inner_knots</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s1">x = x[(lower_bound &lt;= x) &amp; (x &lt;= upper_bound)]</span>
        <span class="s1">x = np.unique(x)</span>

        <span class="s3">if </span><span class="s1">x.size != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">inner_knots_q = np.linspace(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s1">n_inner_knots + </span><span class="s5">2</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0"># .tolist() is necessary to work around a bug in numpy 1.8</span>
            <span class="s1">inner_knots = np.asarray(np.percentile(x</span><span class="s3">, </span><span class="s1">inner_knots_q.tolist()))</span>
        <span class="s3">elif </span><span class="s1">n_inner_knots == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">inner_knots = np.array([])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No data values between lower_bound(=%r) and &quot;</span>
                             <span class="s2">&quot;upper_bound(=%r): cannot compute requested &quot;</span>
                             <span class="s2">&quot;%r inner knot(s).&quot;</span>
                             <span class="s1">% (lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">, </span><span class="s1">n_inner_knots))</span>
    <span class="s3">elif </span><span class="s1">inner_knots </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">inner_knots = np.unique(inner_knots)</span>
        <span class="s3">if </span><span class="s1">n_inner_knots </span><span class="s3">is not None and </span><span class="s1">n_inner_knots != inner_knots.size:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Needed number of inner knots=%r does not match &quot;</span>
                             <span class="s2">&quot;provided number of inner knots=%r.&quot;</span>
                             <span class="s1">% (n_inner_knots</span><span class="s3">, </span><span class="s1">inner_knots.size))</span>
        <span class="s1">n_inner_knots = inner_knots.size</span>
        <span class="s3">if </span><span class="s1">np.any(inner_knots &lt; lower_bound):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Some knot values (%s) fall below lower bound &quot;</span>
                             <span class="s2">&quot;(%r).&quot;</span>
                             <span class="s1">% (inner_knots[inner_knots &lt; lower_bound]</span><span class="s3">,</span>
                                <span class="s1">lower_bound))</span>
        <span class="s3">if </span><span class="s1">np.any(inner_knots &gt; upper_bound):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Some knot values (%s) fall above upper bound &quot;</span>
                             <span class="s2">&quot;(%r).&quot;</span>
                             <span class="s1">% (inner_knots[inner_knots &gt; upper_bound]</span><span class="s3">,</span>
                                <span class="s1">upper_bound))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Must specify either 'n_inner_knots' or 'inner_knots'.&quot;</span><span class="s1">)</span>

    <span class="s1">all_knots = np.concatenate(([lower_bound</span><span class="s3">, </span><span class="s1">upper_bound]</span><span class="s3">, </span><span class="s1">inner_knots))</span>
    <span class="s1">all_knots = np.unique(all_knots)</span>
    <span class="s3">if </span><span class="s1">all_knots.size != n_inner_knots + </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unable to compute n_inner_knots(=%r) + 2 distinct &quot;</span>
                         <span class="s2">&quot;knots: %r data value(s) found between &quot;</span>
                         <span class="s2">&quot;lower_bound(=%r) and upper_bound(=%r).&quot;</span>
                         <span class="s1">% (n_inner_knots</span><span class="s3">, </span><span class="s1">x.size</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound))</span>

    <span class="s3">return </span><span class="s1">all_knots</span>


<span class="s3">def </span><span class="s1">test__get_all_sorted_knots():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">5</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">np.array([])</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">x = np.arange(</span><span class="s5">6</span><span class="s1">) * </span><span class="s5">2</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">8</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s1">])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">9</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">9</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1.3</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">1.4</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">inner_knots=[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s1">inner_knots=[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(</span>
        <span class="s1">_get_all_sorted_knots(x</span><span class="s3">, </span><span class="s1">inner_knots=[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s1">inner_knots=[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">_get_all_sorted_knots</span><span class="s3">,</span>
                  <span class="s1">x</span><span class="s3">, </span><span class="s1">inner_knots=[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s5">6</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_get_centering_constraint_from_dmatrix(design_matrix):</span>
    <span class="s4">&quot;&quot;&quot; Computes the centering constraint from the given design matrix. 
 
    We want to ensure that if ``b`` is the array of parameters, our 
    model is centered, ie ``np.mean(np.dot(design_matrix, b))`` is zero. 
    We can rewrite this as ``np.dot(c, b)`` being zero with ``c`` a 1-row 
    constraint matrix containing the mean of each column of ``design_matrix``. 
 
    :param design_matrix: The 2-d array design matrix. 
    :return: A 2-d array (1 x ncols(design_matrix)) defining the 
     centering constraint. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">design_matrix.mean(axis=</span><span class="s5">0</span><span class="s1">).reshape((</span><span class="s5">1</span><span class="s3">, </span><span class="s1">design_matrix.shape[</span><span class="s5">1</span><span class="s1">]))</span>


<span class="s3">class </span><span class="s1">CubicRegressionSpline(object):</span>
    <span class="s4">&quot;&quot;&quot;Base class for cubic regression spline stateful transforms 
 
    This class contains all the functionality for the following stateful 
    transforms: 
     - ``cr(x, df=None, knots=None, lower_bound=None, upper_bound=None, constraints=None)`` 
       for natural cubic regression spline 
     - ``cc(x, df=None, knots=None, lower_bound=None, upper_bound=None, constraints=None)`` 
       for cyclic cubic regression spline 
    &quot;&quot;&quot;</span>
    <span class="s1">common_doc = </span><span class="s2">&quot;&quot;&quot; 
    :arg df: The number of degrees of freedom to use for this spline. The 
      return value will have this many columns. You must specify at least one 
      of ``df`` and ``knots``. 
    :arg knots: The interior knots to use for the spline. If unspecified, then 
      equally spaced quantiles of the input data are used. You must specify at 
      least one of ``df`` and ``knots``. 
    :arg lower_bound: The lower exterior knot location. 
    :arg upper_bound: The upper exterior knot location. 
    :arg constraints: Either a 2-d array defining general linear constraints 
     (that is ``np.dot(constraints, betas)`` is zero, where ``betas`` denotes 
     the array of *initial* parameters, corresponding to the *initial* 
     unconstrained design matrix), or the string 
     ``'center'`` indicating that we should apply a centering constraint 
     (this constraint will be computed from the input data, remembered and 
     re-used for prediction from the fitted model). 
     The constraints are absorbed in the resulting design matrix which means 
     that the model is actually rewritten in terms of 
     *unconstrained* parameters. For more details see :ref:`spline-regression`. 
 
    This is a stateful transforms (for details see 
    :ref:`stateful-transforms`). If ``knots``, ``lower_bound``, or 
    ``upper_bound`` are not specified, they will be calculated from the data 
    and then the chosen values will be remembered and re-used for prediction 
    from the fitted model. 
 
    Using this function requires scipy be installed. 
 
    .. versionadded:: 0.3.0 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">cyclic):</span>
        <span class="s1">self._name = name</span>
        <span class="s1">self._cyclic = cyclic</span>
        <span class="s1">self._tmp = {}</span>
        <span class="s1">self._all_knots = </span><span class="s3">None</span>
        <span class="s1">self._constraints = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">memorize_chunk(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s3">None, </span><span class="s1">knots=</span><span class="s3">None,</span>
                       <span class="s1">lower_bound=</span><span class="s3">None, </span><span class="s1">upper_bound=</span><span class="s3">None,</span>
                       <span class="s1">constraints=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">args = {</span><span class="s2">&quot;df&quot;</span><span class="s1">: df</span><span class="s3">,</span>
                <span class="s2">&quot;knots&quot;</span><span class="s1">: knots</span><span class="s3">,</span>
                <span class="s2">&quot;lower_bound&quot;</span><span class="s1">: lower_bound</span><span class="s3">,</span>
                <span class="s2">&quot;upper_bound&quot;</span><span class="s1">: upper_bound</span><span class="s3">,</span>
                <span class="s2">&quot;constraints&quot;</span><span class="s1">: constraints</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s1">self._tmp[</span><span class="s2">&quot;args&quot;</span><span class="s1">] = args</span>

        <span class="s1">x = np.atleast_1d(x)</span>
        <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">x.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">x.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Input to %r must be 1-d, &quot;</span>
                             <span class="s2">&quot;or a 2-d column vector.&quot;</span>
                             <span class="s1">% (self._name</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s1">self._tmp.setdefault(</span><span class="s2">&quot;xs&quot;</span><span class="s3">, </span><span class="s1">[]).append(x)</span>

    <span class="s3">def </span><span class="s1">memorize_finish(self):</span>
        <span class="s1">args = self._tmp[</span><span class="s2">&quot;args&quot;</span><span class="s1">]</span>
        <span class="s1">xs = self._tmp[</span><span class="s2">&quot;xs&quot;</span><span class="s1">]</span>
        <span class="s0"># Guards against invalid subsequent memorize_chunk() calls.</span>
        <span class="s3">del </span><span class="s1">self._tmp</span>

        <span class="s1">x = np.concatenate(xs)</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] </span><span class="s3">is None and </span><span class="s1">args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Must specify either 'df' or 'knots'.&quot;</span><span class="s1">)</span>

        <span class="s1">constraints = args[</span><span class="s2">&quot;constraints&quot;</span><span class="s1">]</span>
        <span class="s1">n_constraints = </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">constraints </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">safe_string_eq(constraints</span><span class="s3">, </span><span class="s2">&quot;center&quot;</span><span class="s1">):</span>
                <span class="s0"># Here we collect only number of constraints,</span>
                <span class="s0"># actual centering constraint will be computed after all_knots</span>
                <span class="s1">n_constraints = </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">constraints = np.atleast_2d(constraints)</span>
                <span class="s3">if </span><span class="s1">constraints.ndim != </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Constraints must be 2-d array or &quot;</span>
                                     <span class="s2">&quot;1-d vector.&quot;</span><span class="s1">)</span>
                <span class="s1">n_constraints = constraints.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">n_inner_knots = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">min_df = </span><span class="s5">1</span>
            <span class="s3">if not </span><span class="s1">self._cyclic </span><span class="s3">and </span><span class="s1">n_constraints == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">min_df = </span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] &lt; min_df:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'df'=%r must be greater than or equal to %r.&quot;</span>
                                 <span class="s1">% (args[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">min_df))</span>
            <span class="s1">n_inner_knots = args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] - </span><span class="s5">2 </span><span class="s1">+ n_constraints</span>
            <span class="s3">if </span><span class="s1">self._cyclic:</span>
                <span class="s1">n_inner_knots += </span><span class="s5">1</span>
        <span class="s1">self._all_knots = _get_all_sorted_knots(x</span><span class="s3">,</span>
                                                <span class="s1">n_inner_knots=n_inner_knots</span><span class="s3">,</span>
                                                <span class="s1">inner_knots=args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">]</span><span class="s3">,</span>
                                                <span class="s1">lower_bound=args[</span><span class="s2">&quot;lower_bound&quot;</span><span class="s1">]</span><span class="s3">,</span>
                                                <span class="s1">upper_bound=args[</span><span class="s2">&quot;upper_bound&quot;</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">constraints </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">safe_string_eq(constraints</span><span class="s3">, </span><span class="s2">&quot;center&quot;</span><span class="s1">):</span>
                <span class="s0"># Now we can compute centering constraints</span>
                <span class="s1">constraints = _get_centering_constraint_from_dmatrix(</span>
                    <span class="s1">_get_free_crs_dmatrix(x</span><span class="s3">, </span><span class="s1">self._all_knots</span><span class="s3">, </span><span class="s1">cyclic=self._cyclic)</span>
                <span class="s1">)</span>

            <span class="s1">df_before_constraints = self._all_knots.size</span>
            <span class="s3">if </span><span class="s1">self._cyclic:</span>
                <span class="s1">df_before_constraints -= </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">constraints.shape[</span><span class="s5">1</span><span class="s1">] != df_before_constraints:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Constraints array should have %r columns but&quot;</span>
                                 <span class="s2">&quot; %r found.&quot;</span>
                                 <span class="s1">% (df_before_constraints</span><span class="s3">, </span><span class="s1">constraints.shape[</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">self._constraints = constraints</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s3">None, </span><span class="s1">knots=</span><span class="s3">None,</span>
                  <span class="s1">lower_bound=</span><span class="s3">None, </span><span class="s1">upper_bound=</span><span class="s3">None,</span>
                  <span class="s1">constraints=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">x_orig = x</span>
        <span class="s1">x = np.atleast_1d(x)</span>
        <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">x.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">x.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Input to %r must be 1-d, &quot;</span>
                             <span class="s2">&quot;or a 2-d column vector.&quot;</span>
                             <span class="s1">% (self._name</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">dm = _get_crs_dmatrix(x</span><span class="s3">, </span><span class="s1">self._all_knots</span><span class="s3">,</span>
                              <span class="s1">self._constraints</span><span class="s3">, </span><span class="s1">cyclic=self._cyclic)</span>
        <span class="s3">if </span><span class="s1">have_pandas:</span>
            <span class="s3">if </span><span class="s1">isinstance(x_orig</span><span class="s3">, </span><span class="s1">(pandas.Series</span><span class="s3">, </span><span class="s1">pandas.DataFrame)):</span>
                <span class="s1">dm = pandas.DataFrame(dm)</span>
                <span class="s1">dm.index = x_orig.index</span>
        <span class="s3">return </span><span class="s1">dm</span>

    <span class="s1">__getstate__ = no_pickling</span>


<span class="s3">class </span><span class="s1">CR(CubicRegressionSpline):</span>
    <span class="s4">&quot;&quot;&quot;cr(x, df=None, knots=None, lower_bound=None, upper_bound=None, constraints=None) 
 
    Generates a natural cubic spline basis for ``x`` 
    (with the option of absorbing centering or more general parameters 
    constraints), allowing non-linear fits. The usual usage is something like:: 
 
      y ~ 1 + cr(x, df=5, constraints='center') 
 
    to fit ``y`` as a smooth function of ``x``, with 5 degrees of freedom 
    given to the smooth, and centering constraint absorbed in 
    the resulting design matrix. Note that in this example, due to the centering 
    constraint, 6 knots will get computed from the input data ``x`` 
    to achieve 5 degrees of freedom. 
 
 
    .. note:: This function reproduce the cubic regression splines 'cr' and 'cs' 
      as implemented in the R package 'mgcv' (GAM modelling). 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># Under python -OO, __doc__ will be defined but set to None</span>
    <span class="s3">if </span><span class="s1">__doc__:</span>
        <span class="s1">__doc__ += CubicRegressionSpline.common_doc</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CubicRegressionSpline.__init__(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s2">'cr'</span><span class="s3">, </span><span class="s1">cyclic=</span><span class="s3">False</span><span class="s1">)</span>

<span class="s1">cr = stateful_transform(CR)</span>


<span class="s3">class </span><span class="s1">CC(CubicRegressionSpline):</span>
    <span class="s4">&quot;&quot;&quot;cc(x, df=None, knots=None, lower_bound=None, upper_bound=None, constraints=None) 
 
    Generates a cyclic cubic spline basis for ``x`` 
    (with the option of absorbing centering or more general parameters 
    constraints), allowing non-linear fits. The usual usage is something like:: 
 
      y ~ 1 + cc(x, df=7, constraints='center') 
 
    to fit ``y`` as a smooth function of ``x``, with 7 degrees of freedom 
    given to the smooth, and centering constraint absorbed in 
    the resulting design matrix. Note that in this example, due to the centering 
    and cyclic constraints, 9 knots will get computed from the input data ``x`` 
    to achieve 7 degrees of freedom. 
 
    .. note:: This function reproduce the cubic regression splines 'cc' 
      as implemented in the R package 'mgcv' (GAM modelling). 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># Under python -OO, __doc__ will be defined but set to None</span>
    <span class="s3">if </span><span class="s1">__doc__:</span>
        <span class="s1">__doc__ += CubicRegressionSpline.common_doc</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CubicRegressionSpline.__init__(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s2">'cc'</span><span class="s3">, </span><span class="s1">cyclic=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">cc = stateful_transform(CC)</span>


<span class="s3">def </span><span class="s1">test_crs_errors():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s0"># Invalid 'x' shape</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">16</span><span class="s1">).reshape((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">CR().transform</span><span class="s3">,</span>
                  <span class="s1">np.arange(</span><span class="s5">16</span><span class="s1">).reshape((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s0"># Should provide at least 'df' or 'knots'</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">50</span><span class="s1">))</span>
    <span class="s0"># Invalid constraints shape</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">50</span><span class="s1">)</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s3">,</span>
                  <span class="s1">constraints=np.arange(</span><span class="s5">27</span><span class="s1">).reshape((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)))</span>
    <span class="s0"># Invalid nb of columns in constraints</span>
    <span class="s0"># (should have df + 1 = 5, but 6 provided)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">50</span><span class="s1">)</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s3">,</span>
                  <span class="s1">constraints=np.arange(</span><span class="s5">6</span><span class="s1">))</span>
    <span class="s0"># Too small 'df' for natural cubic spline</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cr</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">50</span><span class="s1">)</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0"># Too small 'df' for cyclic cubic spline</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">cc</span><span class="s3">, </span><span class="s1">np.arange(</span><span class="s5">50</span><span class="s1">)</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_crs_compat():</span>
    <span class="s3">from </span><span class="s1">patsy.test_state </span><span class="s3">import </span><span class="s1">check_stateful</span>
    <span class="s3">from </span><span class="s1">patsy.test_splines_crs_data </span><span class="s3">import </span><span class="s1">(R_crs_test_x</span><span class="s3">,</span>
                                             <span class="s1">R_crs_test_data</span><span class="s3">,</span>
                                             <span class="s1">R_crs_num_tests)</span>
    <span class="s1">lines = R_crs_test_data.split(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
    <span class="s1">tests_ran = </span><span class="s5">0</span>
    <span class="s1">start_idx = lines.index(</span><span class="s2">&quot;--BEGIN TEST CASE--&quot;</span><span class="s1">)</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">lines[start_idx] == </span><span class="s2">&quot;--BEGIN TEST CASE--&quot;</span><span class="s1">:</span>
            <span class="s3">break</span>
        <span class="s1">start_idx += </span><span class="s5">1</span>
        <span class="s1">stop_idx = lines.index(</span><span class="s2">&quot;--END TEST CASE--&quot;</span><span class="s3">, </span><span class="s1">start_idx)</span>
        <span class="s1">block = lines[start_idx:stop_idx]</span>
        <span class="s1">test_data = {}</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">key</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s2">&quot;=&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">test_data[key] = value</span>
        <span class="s0"># Translate the R output into Python calling conventions</span>
        <span class="s1">adjust_df = </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">test_data[</span><span class="s2">&quot;spline_type&quot;</span><span class="s1">] == </span><span class="s2">&quot;cr&quot; </span><span class="s3">or </span><span class="s1">test_data[</span><span class="s2">&quot;spline_type&quot;</span><span class="s1">] == </span><span class="s2">&quot;cs&quot;</span><span class="s1">:</span>
            <span class="s1">spline_type = CR</span>
        <span class="s3">elif </span><span class="s1">test_data[</span><span class="s2">&quot;spline_type&quot;</span><span class="s1">] == </span><span class="s2">&quot;cc&quot;</span><span class="s1">:</span>
            <span class="s1">spline_type = CC</span>
            <span class="s1">adjust_df += </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unrecognized spline type %r&quot;</span>
                             <span class="s1">% (test_data[</span><span class="s2">&quot;spline_type&quot;</span><span class="s1">]</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">kwargs = {}</span>
        <span class="s3">if </span><span class="s1">test_data[</span><span class="s2">&quot;absorb_cons&quot;</span><span class="s1">] == </span><span class="s2">&quot;TRUE&quot;</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;constraints&quot;</span><span class="s1">] = </span><span class="s2">&quot;center&quot;</span>
            <span class="s1">adjust_df += </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">test_data[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] != </span><span class="s2">&quot;None&quot;</span><span class="s1">:</span>
            <span class="s1">all_knots = np.asarray(eval(test_data[</span><span class="s2">&quot;knots&quot;</span><span class="s1">]))</span>
            <span class="s1">all_knots.sort()</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] = all_knots[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;lower_bound&quot;</span><span class="s1">] = all_knots[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;upper_bound&quot;</span><span class="s1">] = all_knots[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;df&quot;</span><span class="s1">] = eval(test_data[</span><span class="s2">&quot;nb_knots&quot;</span><span class="s1">]) - adjust_df</span>
        <span class="s1">output = np.asarray(eval(test_data[</span><span class="s2">&quot;output&quot;</span><span class="s1">]))</span>
        <span class="s0"># Do the actual test</span>
        <span class="s1">check_stateful(spline_type</span><span class="s3">, False, </span><span class="s1">R_crs_test_x</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">tests_ran += </span><span class="s5">1</span>
        <span class="s0"># Set up for the next one</span>
        <span class="s1">start_idx = stop_idx + </span><span class="s5">1</span>
    <span class="s3">assert </span><span class="s1">tests_ran == R_crs_num_tests</span>

<span class="s1">test_crs_compat.slow = </span><span class="s3">True</span>

<span class="s3">def </span><span class="s1">test_crs_with_specific_constraint():</span>
    <span class="s3">from </span><span class="s1">patsy.highlevel </span><span class="s3">import </span><span class="s1">incr_dbuilder</span><span class="s3">, </span><span class="s1">build_design_matrices</span><span class="s3">, </span><span class="s1">dmatrix</span>
    <span class="s1">x = (-</span><span class="s5">1.5</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s0"># Hard coded R values for smooth: s(x, bs=&quot;cr&quot;, k=5)</span>
    <span class="s0"># R&gt; knots &lt;- smooth$xp</span>
    <span class="s1">knots_R = np.array([-</span><span class="s5">2216.837820053100585937</span><span class="s3">,</span>
                        <span class="s1">-</span><span class="s5">50.456909179687500000</span><span class="s3">,</span>
                        <span class="s1">-</span><span class="s5">0.250000000000000000</span><span class="s3">,</span>
                        <span class="s5">33.637939453125000000</span><span class="s3">,</span>
                        <span class="s5">1477.891880035400390625</span><span class="s1">])</span>
    <span class="s0"># R&gt; centering.constraint &lt;- t(qr.X(attr(smooth, &quot;qrc&quot;)))</span>
    <span class="s1">centering_constraint_R = np.array([[</span><span class="s5">0.064910676323168478574</span><span class="s3">,</span>
                                        <span class="s5">1.4519875239407085132</span><span class="s3">,</span>
                                        <span class="s1">-</span><span class="s5">2.1947446912471946234</span><span class="s3">,</span>
                                        <span class="s5">1.6129783104357671153</span><span class="s3">,</span>
                                        <span class="s5">0.064868180547550072235</span><span class="s1">]])</span>
    <span class="s0"># values for which we want a prediction</span>
    <span class="s1">new_x = np.array([-</span><span class="s5">3000.</span><span class="s3">, </span><span class="s1">-</span><span class="s5">200.</span><span class="s3">, </span><span class="s5">300.</span><span class="s3">, </span><span class="s5">2000.</span><span class="s1">])</span>
    <span class="s1">result1 = dmatrix(</span><span class="s2">&quot;cr(new_x, knots=knots_R[1:-1], &quot;</span>
                      <span class="s2">&quot;lower_bound=knots_R[0], upper_bound=knots_R[-1], &quot;</span>
                      <span class="s2">&quot;constraints=centering_constraint_R)&quot;</span><span class="s1">)</span>

    <span class="s1">data_chunked = [{</span><span class="s2">&quot;x&quot;</span><span class="s1">: x[:</span><span class="s5">10</span><span class="s1">]}</span><span class="s3">, </span><span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: x[</span><span class="s5">10</span><span class="s1">:]}]</span>
    <span class="s1">new_data = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: new_x}</span>
    <span class="s1">builder = incr_dbuilder(</span><span class="s2">&quot;cr(x, df=4, constraints='center')&quot;</span><span class="s3">,</span>
                            <span class="s3">lambda</span><span class="s1">: iter(data_chunked))</span>
    <span class="s1">result2 = build_design_matrices([builder]</span><span class="s3">, </span><span class="s1">new_data)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">assert </span><span class="s1">np.allclose(result1</span><span class="s3">, </span><span class="s1">result2</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">0.</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TE(object):</span>
    <span class="s4">&quot;&quot;&quot;te(s1, .., sn, constraints=None) 
 
    Generates smooth of several covariates as a tensor product of the bases 
    of marginal univariate smooths ``s1, .., sn``. The marginal smooths are 
    required to transform input univariate data into some kind of smooth 
    functions basis producing a 2-d array output with the ``(i, j)`` element 
    corresponding to the value of the ``j`` th basis function at the ``i`` th 
    data point. 
    The resulting basis dimension is the product of the basis dimensions of 
    the marginal smooths. The usual usage is something like:: 
 
      y ~ 1 + te(cr(x1, df=5), cc(x2, df=6), constraints='center') 
 
    to fit ``y`` as a smooth function of both ``x1`` and ``x2``, with a natural 
    cubic spline for ``x1`` marginal smooth and a cyclic cubic spline for 
    ``x2`` (and centering constraint absorbed in the resulting design matrix). 
 
    :arg constraints: Either a 2-d array defining general linear constraints 
     (that is ``np.dot(constraints, betas)`` is zero, where ``betas`` denotes 
     the array of *initial* parameters, corresponding to the *initial* 
     unconstrained design matrix), or the string 
     ``'center'`` indicating that we should apply a centering constraint 
     (this constraint will be computed from the input data, remembered and 
     re-used for prediction from the fitted model). 
     The constraints are absorbed in the resulting design matrix which means 
     that the model is actually rewritten in terms of 
     *unconstrained* parameters. For more details see :ref:`spline-regression`. 
 
    Using this function requires scipy be installed. 
 
    .. note:: This function reproduce the tensor product smooth 'te' as 
      implemented in the R package 'mgcv' (GAM modelling). 
      See also 'Generalized Additive Models', Simon N. Wood, 2006, pp 158-163 
 
    .. versionadded:: 0.3.0 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._tmp = {}</span>
        <span class="s1">self._constraints = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">memorize_chunk(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">constraints = self._tmp.setdefault(</span><span class="s2">&quot;constraints&quot;</span><span class="s3">,</span>
                                           <span class="s1">kwargs.get(</span><span class="s2">&quot;constraints&quot;</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">safe_string_eq(constraints</span><span class="s3">, </span><span class="s2">&quot;center&quot;</span><span class="s1">):</span>
            <span class="s1">args_2d = []</span>
            <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args:</span>
                <span class="s1">arg = atleast_2d_column_default(arg)</span>
                <span class="s3">if </span><span class="s1">arg.ndim != </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Each tensor product argument must be &quot;</span>
                                     <span class="s2">&quot;a 2-d array or 1-d vector.&quot;</span><span class="s1">)</span>
                <span class="s1">args_2d.append(arg)</span>

            <span class="s1">tp = _row_tensor_product(args_2d)</span>
            <span class="s1">self._tmp.setdefault(</span><span class="s2">&quot;count&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">self._tmp[</span><span class="s2">&quot;count&quot;</span><span class="s1">] += tp.shape[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">chunk_sum = np.atleast_2d(tp.sum(axis=</span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">self._tmp.setdefault(</span><span class="s2">&quot;sum&quot;</span><span class="s3">, </span><span class="s1">np.zeros(chunk_sum.shape))</span>
            <span class="s1">self._tmp[</span><span class="s2">&quot;sum&quot;</span><span class="s1">] += chunk_sum</span>

    <span class="s3">def </span><span class="s1">memorize_finish(self):</span>
        <span class="s1">tmp = self._tmp</span>
        <span class="s1">constraints = self._tmp[</span><span class="s2">&quot;constraints&quot;</span><span class="s1">]</span>
        <span class="s0"># Guards against invalid subsequent memorize_chunk() calls.</span>
        <span class="s3">del </span><span class="s1">self._tmp</span>

        <span class="s3">if </span><span class="s1">constraints </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">safe_string_eq(constraints</span><span class="s3">, </span><span class="s2">&quot;center&quot;</span><span class="s1">):</span>
                <span class="s1">constraints = np.atleast_2d(tmp[</span><span class="s2">&quot;sum&quot;</span><span class="s1">] / tmp[</span><span class="s2">&quot;count&quot;</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">constraints = np.atleast_2d(constraints)</span>
                <span class="s3">if </span><span class="s1">constraints.ndim != </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Constraints must be 2-d array or &quot;</span>
                                     <span class="s2">&quot;1-d vector.&quot;</span><span class="s1">)</span>

        <span class="s1">self._constraints = constraints</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">args_2d = []</span>
        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">arg = atleast_2d_column_default(arg)</span>
            <span class="s3">if </span><span class="s1">arg.ndim != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Each tensor product argument must be &quot;</span>
                                 <span class="s2">&quot;a 2-d array or 1-d vector.&quot;</span><span class="s1">)</span>
            <span class="s1">args_2d.append(arg)</span>

        <span class="s3">return </span><span class="s1">_get_te_dmatrix(args_2d</span><span class="s3">, </span><span class="s1">self._constraints)</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s1">te = stateful_transform(TE)</span>


<span class="s3">def </span><span class="s1">test_te_errors():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s1">x = np.arange(</span><span class="s5">27</span><span class="s1">)</span>
    <span class="s0"># Invalid input shape</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">te</span><span class="s3">, </span><span class="s1">x.reshape((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)))</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">te</span><span class="s3">, </span><span class="s1">x.reshape((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">, </span><span class="s1">constraints=</span><span class="s2">'center'</span><span class="s1">)</span>
    <span class="s0"># Invalid constraints shape</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">te</span><span class="s3">, </span><span class="s1">x</span><span class="s3">,</span>
                  <span class="s1">constraints=np.arange(</span><span class="s5">8</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)))</span>


<span class="s3">def </span><span class="s1">test_te_1smooth():</span>
    <span class="s3">from </span><span class="s1">patsy.splines </span><span class="s3">import </span><span class="s1">bs</span>
    <span class="s0"># Tensor product of 1 smooth covariate should be the same</span>
    <span class="s0"># as the smooth alone</span>
    <span class="s1">x = (-</span><span class="s5">1.5</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.allclose(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">6</span><span class="s1">)</span><span class="s3">, </span><span class="s1">te(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">6</span><span class="s1">)))</span>
    <span class="s3">assert </span><span class="s1">np.allclose(cc(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">te(cc(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">5</span><span class="s1">)))</span>
    <span class="s3">assert </span><span class="s1">np.allclose(bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">te(bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)))</span>
    <span class="s0"># Adding centering constraint to tensor product</span>
    <span class="s3">assert </span><span class="s1">np.allclose(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">constraints=</span><span class="s2">'center'</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">te(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">constraints=</span><span class="s2">'center'</span><span class="s1">))</span>
    <span class="s0"># Adding specific constraint</span>
    <span class="s1">center_constraint = np.arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.allclose(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">constraints=center_constraint)</span><span class="s3">,</span>
                       <span class="s1">te(cr(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">constraints=center_constraint))</span>


<span class="s3">def </span><span class="s1">test_te_2smooths():</span>
    <span class="s3">from </span><span class="s1">patsy.highlevel </span><span class="s3">import </span><span class="s1">incr_dbuilder</span><span class="s3">, </span><span class="s1">build_design_matrices</span>
    <span class="s1">x1 = (-</span><span class="s5">1.5</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">x2 = (</span><span class="s5">1.6</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s0"># Hard coded R results for smooth: te(x1, x2, bs=c(&quot;cs&quot;, &quot;cc&quot;), k=c(5,7))</span>
    <span class="s0"># Without centering constraint:</span>
    <span class="s1">dmatrix_R_nocons = \</span>
        <span class="s1">np.array([[-</span><span class="s5">4.4303024184609255207e-06</span><span class="s3">,  </span><span class="s5">7.9884438387230142235e-06</span><span class="s3">,</span>
                   <span class="s5">9.7987758194797719025e-06</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">7.2894213245475212959e-08</span><span class="s3">,</span>
                   <span class="s5">1.5907686862964493897e-09</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">3.2565884983072595159e-11</span><span class="s3">,</span>
                   <span class="s5">0.0170749607855874667439</span><span class="s3">,    </span><span class="s1">-</span><span class="s5">3.0788499835965849050e-02</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">3.7765754357352458725e-02</span><span class="s3">,  </span><span class="s5">2.8094376299826799787e-04</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">6.1310290747349201414e-06</span><span class="s3">,  </span><span class="s5">1.2551314933193442915e-07</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">0.26012671685838206770</span><span class="s3">,     </span><span class="s5">4.6904420337437874311e-01</span><span class="s3">,</span>
                   <span class="s5">0.5753384627946153129230</span><span class="s3">,    </span><span class="s1">-</span><span class="s5">4.2800085814700449330e-03</span><span class="s3">,</span>
                   <span class="s5">9.3402525733484874533e-05</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.9121170389937518131e-06</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">0.0904312240489447832781</span><span class="s3">,   </span><span class="s5">1.6305991924427923334e-01</span><span class="s3">,</span>
                   <span class="s5">2.0001237112941641638e-01</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.4879148887003382663e-03</span><span class="s3">,</span>
                   <span class="s5">3.2470731316462736135e-05</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">6.6473404365914134499e-07</span><span class="s3">,</span>
                   <span class="s5">2.0447857920168824846e-05</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">3.6870296695050991799e-05</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">4.5225801045409022233e-05</span><span class="s3">,  </span><span class="s5">3.3643990293641665710e-07</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">7.3421200200015877329e-09</span><span class="s3">,  </span><span class="s5">1.5030635073660743297e-10</span><span class="s1">]</span><span class="s3">,</span>
                  <span class="s1">[-</span><span class="s5">9.4006130602653794302e-04</span><span class="s3">,  </span><span class="s5">7.8681398069163730347e-04</span><span class="s3">,</span>
                   <span class="s5">2.4573006857381437217e-04</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.4524712230452725106e-04</span><span class="s3">,</span>
                   <span class="s5">7.8216741353106329551e-05</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">3.1304283003914264551e-04</span><span class="s3">,</span>
                   <span class="s5">3.6231183382798337611064</span><span class="s3">,    </span><span class="s1">-</span><span class="s5">3.0324832476174168328e+00</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">9.4707559178211142559e-01</span><span class="s3">,  </span><span class="s5">5.5980126937492580286e-01</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">3.0145747744342332730e-01</span><span class="s3">,  </span><span class="s5">1.2065077148806895302e+00</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">35.17561267504181188315</span><span class="s3">,    </span><span class="s5">2.9441339255948005160e+01</span><span class="s3">,</span>
                   <span class="s5">9.1948319320782125885216</span><span class="s3">,    </span><span class="s1">-</span><span class="s5">5.4349184288245195873e+00</span><span class="s3">,</span>
                   <span class="s5">2.9267472035096449012e+00</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.1713569391233907169e+01</span><span class="s3">,</span>
                   <span class="s5">34.0275626863976370373166</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">2.8480442582712722555e+01</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">8.8947340548151565542e+00</span><span class="s3">,  </span><span class="s5">5.2575353623762932642e+00</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">2.8312249982592527786e+00</span><span class="s3">,  </span><span class="s5">1.1331265795534763541e+01</span><span class="s3">,</span>
                   <span class="s5">7.9462158845078978420e-01</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">6.6508361863670617531e-01</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">2.0771242914526857892e-01</span><span class="s3">,  </span><span class="s5">1.2277550230353953542e-01</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">6.6115593588420035198e-02</span><span class="s3">,  </span><span class="s5">2.6461103043402139923e-01</span><span class="s1">]])</span>
    <span class="s0"># With centering constraint:</span>
    <span class="s1">dmatrix_R_cons = \</span>
        <span class="s1">np.array([[</span><span class="s5">0.00329998606323867252343</span><span class="s3">,   </span><span class="s5">1.6537431155796576600e-04</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.2392262709790753433e-04</span><span class="s3">,  </span><span class="s5">6.5405304166706783407e-05</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">6.6764045799537624095e-05</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">0.1386431081763726258504</span><span class="s3">,</span>
                   <span class="s5">0.124297283800864313830</span><span class="s3">,     </span><span class="s1">-</span><span class="s5">3.5487293655619825405e-02</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">3.0527115315785902268e-03</span><span class="s3">,  </span><span class="s5">5.2009247643311604277e-04</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">0.00384203992301702674378</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">0.058901915802819435064</span><span class="s3">,</span>
                   <span class="s5">0.266422358491648914036</span><span class="s3">,     </span><span class="s5">0.5739281693874087597607</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.3171008503525844392e-03</span><span class="s3">,  </span><span class="s5">8.2573456631878912413e-04</span><span class="s3">,</span>
                   <span class="s5">6.6730833453016958831e-03</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">0.1467677784718444955470</span><span class="s3">,</span>
                   <span class="s5">0.220757650934837484913</span><span class="s3">,     </span><span class="s5">0.1983127687880171796664</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.6269930328365173316e-03</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">1.7785892412241208812e-03</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">3.2702835436351201243e-03</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">4.3252183044300757109e-02</span><span class="s3">,</span>
                   <span class="s5">4.3403766976235179376e-02</span><span class="s3">,   </span><span class="s5">3.5973406402893762387e-05</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">5.4035858568225075046e-04</span><span class="s3">,  </span><span class="s5">2.9565209382794241247e-04</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">2.2769990750264097637e-04</span><span class="s1">]</span><span class="s3">,</span>
                  <span class="s1">[</span><span class="s5">0.41547954838956052681098</span><span class="s3">,   </span><span class="s5">1.9843570584107707994e-02</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.5746590234791378593e-02</span><span class="s3">,  </span><span class="s5">8.3171184312221431434e-03</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">8.7233014052017516377e-03</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">15.9926770785086258541696</span><span class="s3">,</span>
                   <span class="s5">16.503663226274017716833</span><span class="s3">,    </span><span class="s1">-</span><span class="s5">6.6005803955894726265e-01</span><span class="s3">,</span>
                   <span class="s5">1.3986092022708346283e-01</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">2.3516913533670955050e-01</span><span class="s3">,</span>
                   <span class="s5">0.72251037497207359905360</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">9.827337059999853963177</span><span class="s3">,</span>
                   <span class="s5">3.917078117294827688255</span><span class="s3">,     </span><span class="s5">9.0171773596973618936090</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">5.0616811270787671617e+00</span><span class="s3">,  </span><span class="s5">3.0189990249009683865e+00</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.0872720629943064097e+01</span><span class="s3">,  </span><span class="s5">26.9308504460453121964747</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">21.212262927009287949431</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">9.1088328555582247503253</span><span class="s3">,</span>
                   <span class="s5">5.2400156972500298025e+00</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">3.0593641098325474736e+00</span><span class="s3">,</span>
                   <span class="s5">1.0919392118399086300e+01</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">4.6564290223265718538e+00</span><span class="s3">,</span>
                   <span class="s5">4.8071307441606982991e+00</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.9748377005689798924e-01</span><span class="s3">,</span>
                   <span class="s5">5.4664183716965096538e-02</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">2.8871392916916285148e-02</span><span class="s3">,</span>
                   <span class="s5">2.3592766838010845176e-01</span><span class="s1">]])</span>
    <span class="s1">new_x1 = np.array([</span><span class="s5">11.390625</span><span class="s3">, </span><span class="s5">656.84083557128906250</span><span class="s1">])</span>
    <span class="s1">new_x2 = np.array([</span><span class="s5">16.777216000000006346</span><span class="s3">, </span><span class="s5">1844.6744073709567147</span><span class="s1">])</span>
    <span class="s1">new_data = {</span><span class="s2">&quot;x1&quot;</span><span class="s1">: new_x1</span><span class="s3">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">: new_x2}</span>
    <span class="s1">data_chunked = [{</span><span class="s2">&quot;x1&quot;</span><span class="s1">: x1[:</span><span class="s5">10</span><span class="s1">]</span><span class="s3">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">: x2[:</span><span class="s5">10</span><span class="s1">]}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s2">&quot;x1&quot;</span><span class="s1">: x1[</span><span class="s5">10</span><span class="s1">:]</span><span class="s3">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">: x2[</span><span class="s5">10</span><span class="s1">:]}]</span>

    <span class="s1">builder = incr_dbuilder(</span><span class="s2">&quot;te(cr(x1, df=5), cc(x2, df=6)) - 1&quot;</span><span class="s3">,</span>
                            <span class="s3">lambda</span><span class="s1">: iter(data_chunked))</span>
    <span class="s1">dmatrix_nocons = build_design_matrices([builder]</span><span class="s3">, </span><span class="s1">new_data)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">np.allclose(dmatrix_nocons</span><span class="s3">, </span><span class="s1">dmatrix_R_nocons</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">0.</span><span class="s1">)</span>

    <span class="s1">builder = incr_dbuilder(</span><span class="s2">&quot;te(cr(x1, df=5), cc(x2, df=6), &quot;</span>
                            <span class="s2">&quot;constraints='center') - 1&quot;</span><span class="s3">,</span>
                            <span class="s3">lambda</span><span class="s1">: iter(data_chunked))</span>
    <span class="s1">dmatrix_cons = build_design_matrices([builder]</span><span class="s3">, </span><span class="s1">new_data)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">np.allclose(dmatrix_cons</span><span class="s3">, </span><span class="s1">dmatrix_R_cons</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">0.</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_te_3smooths():</span>
    <span class="s3">from </span><span class="s1">patsy.highlevel </span><span class="s3">import </span><span class="s1">incr_dbuilder</span><span class="s3">, </span><span class="s1">build_design_matrices</span>
    <span class="s1">x1 = (-</span><span class="s5">1.5</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">x2 = (</span><span class="s5">1.6</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">x3 = (-</span><span class="s5">1.2</span><span class="s1">)**np.arange(</span><span class="s5">20</span><span class="s1">)</span>
    <span class="s0"># Hard coded R results for smooth:  te(x1, x2, x3, bs=c(&quot;cr&quot;, &quot;cs&quot;, &quot;cc&quot;), k=c(3,3,4))</span>
    <span class="s1">design_matrix_R = \</span>
        <span class="s1">np.array([[</span><span class="s5">7.2077663709837084334e-05</span><span class="s3">,   </span><span class="s5">2.0648333344343273131e-03</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">4.7934014082310591768e-04</span><span class="s3">,  </span><span class="s5">2.3923430783992746568e-04</span><span class="s3">,</span>
                   <span class="s5">6.8534265421922660466e-03</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">1.5909867344112936776e-03</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">6.8057712777151204314e-09</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">1.9496724335203412851e-07</span><span class="s3">,</span>
                   <span class="s5">4.5260614658693259131e-08</span><span class="s3">,   </span><span class="s5">0.0101479754187435277507</span><span class="s3">,</span>
                   <span class="s5">0.290712501531622591333</span><span class="s3">,     </span><span class="s1">-</span><span class="s5">0.067487370093906928759</span><span class="s3">,</span>
                   <span class="s5">0.03368233306025386619709</span><span class="s3">,   </span><span class="s5">0.9649092451763204847381</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">0.2239985793289433757547</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">9.5819975394704535133e-07</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">2.7449874082511405643e-05</span><span class="s3">,  </span><span class="s5">6.3723431275833230217e-06</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.5205851762850489204e-04</span><span class="s3">,  </span><span class="s1">-</span><span class="s5">0.00435607204539782688624</span><span class="s3">,</span>
                   <span class="s5">0.00101123909269346416370</span><span class="s3">,   </span><span class="s1">-</span><span class="s5">5.0470024059694933508e-04</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">1.4458319360584082416e-02</span><span class="s3">,  </span><span class="s5">3.3564223914790921634e-03</span><span class="s3">,</span>
                   <span class="s5">1.4357783514933466209e-08</span><span class="s3">,   </span><span class="s5">4.1131230514870551983e-07</span><span class="s3">,</span>
                   <span class="s1">-</span><span class="s5">9.5483976834512651038e-08</span><span class="s1">]])</span>
    <span class="s1">new_data = {</span><span class="s2">&quot;x1&quot;</span><span class="s1">: -</span><span class="s5">38.443359375000000000</span><span class="s3">,</span>
                <span class="s2">&quot;x2&quot;</span><span class="s1">: </span><span class="s5">68.719476736000032702</span><span class="s3">,</span>
                <span class="s2">&quot;x3&quot;</span><span class="s1">: -</span><span class="s5">5.1597803519999985156</span><span class="s1">}</span>
    <span class="s1">data_chunked = [{</span><span class="s2">&quot;x1&quot;</span><span class="s1">: x1[:</span><span class="s5">10</span><span class="s1">]</span><span class="s3">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">: x2[:</span><span class="s5">10</span><span class="s1">]</span><span class="s3">, </span><span class="s2">&quot;x3&quot;</span><span class="s1">: x3[:</span><span class="s5">10</span><span class="s1">]}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s2">&quot;x1&quot;</span><span class="s1">: x1[</span><span class="s5">10</span><span class="s1">:]</span><span class="s3">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">: x2[</span><span class="s5">10</span><span class="s1">:]</span><span class="s3">, </span><span class="s2">&quot;x3&quot;</span><span class="s1">: x3[</span><span class="s5">10</span><span class="s1">:]}]</span>
    <span class="s1">builder = incr_dbuilder(</span><span class="s2">&quot;te(cr(x1, df=3), cr(x2, df=3), cc(x3, df=3)) - 1&quot;</span><span class="s3">,</span>
                            <span class="s3">lambda</span><span class="s1">: iter(data_chunked))</span>
    <span class="s1">design_matrix = build_design_matrices([builder]</span><span class="s3">, </span><span class="s1">new_data)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">np.allclose(design_matrix</span><span class="s3">, </span><span class="s1">design_matrix_R</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">0.</span><span class="s1">)</span>
</pre>
</body>
</html>